# Bundle Analyzer Plugin - å…¨æ–°åŠŸèƒ½è®¾è®¡

> **æ–‡æ¡£ä¿®è®¢è¯´æ˜**: æœ¬æ–‡æ¡£å·²æ ¹æ®å®é™…ä»£ç  (crates/spack_plugin_bundle_analyzer/src/lib.rs) è¿›è¡Œæ ¸å¯¹å’Œä¿®æ­£,ä¸»è¦ä¿®æ­£ç‚¹åŒ…æ‹¬:
> - Asset.size ç±»å‹: `usize` (é `u64`)
> - get_module_size å®ç°: ä½¿ç”¨ `module.size(None, None)` (é `original_source()`)
> - collect_assets: æ·»åŠ äº† source å­˜åœ¨æ€§æ£€æŸ¥
> - collect_chunks: `can_be_initial` å‚æ•°ä½¿ç”¨ `&compilation.chunk_group_by_ukey`
> - get_asset_chunks: æ·»åŠ äº† chunk.id() ä¸º None çš„å¤„ç†
> - å‡½æ•°ç­¾åç»†èŠ‚: ä½¿ç”¨ `&Identifier` è€Œé `&ModuleIdentifier`

---

## æ ¸å¿ƒæ¦‚å¿µè¯´æ˜

åœ¨æ·±å…¥è®¾è®¡ä¹‹å‰,å…ˆç†è§£ Bundle Analyzer æ’ä»¶çš„ä¸‰ä¸ªæ ¸å¿ƒæ•°æ®ç»´åº¦:

### ğŸ“¦ Assets (èµ„äº§/è¾“å‡ºæ–‡ä»¶)

**æ˜¯ä»€ä¹ˆ**: æ‰“åŒ…åæœ€ç»ˆè¾“å‡ºåˆ°ç£ç›˜çš„æ–‡ä»¶,ä¹Ÿå°±æ˜¯ç”¨æˆ·å®é™…éƒ¨ç½²åˆ°æœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶ã€‚

**ä¸¾ä¾‹**:
- `main.js` - ä¸»å…¥å£æ–‡ä»¶ (500 KB)
- `vendor.js` - ç¬¬ä¸‰æ–¹åº“æ–‡ä»¶ (1.2 MB)
- `styles.css` - æ ·å¼æ–‡ä»¶ (50 KB)
- `image.png` - å›¾ç‰‡èµ„æº (100 KB)

**ä¸ºä»€ä¹ˆé‡è¦**:
- ç›´æ¥å½±å“ç”¨æˆ·ä¸‹è½½é€Ÿåº¦å’Œé¡µé¢åŠ è½½æ—¶é—´
- æ˜¯æ€§èƒ½ä¼˜åŒ–çš„æœ€ç»ˆè¡¡é‡æŒ‡æ ‡
- éœ€è¦æ§åˆ¶å•ä¸ªæ–‡ä»¶å¤§å° (é¿å…è¶…è¿‡æµè§ˆå™¨ç¼“å­˜é™åˆ¶æˆ– CDN é™åˆ¶)

---

### ğŸ“„ Modules (æ¨¡å—/æºæ–‡ä»¶)

**æ˜¯ä»€ä¹ˆ**: æ„å»ºè¿‡ç¨‹ä¸­å¤„ç†çš„æºä»£ç æ–‡ä»¶,åŒ…æ‹¬ä½ å†™çš„ä»£ç å’Œ node_modules ä¸­çš„ç¬¬ä¸‰æ–¹åº“ã€‚

**ä¸¾ä¾‹**:
- `./src/index.js` - ä½ çš„å…¥å£æ–‡ä»¶
- `./src/components/Button.jsx` - React ç»„ä»¶
- `node_modules/react/index.js` - React åº“çš„å…¥å£
- `node_modules/lodash/debounce.js` - Lodash çš„é˜²æŠ–å‡½æ•°

**ä¸ºä»€ä¹ˆé‡è¦**:
- å¯ä»¥åˆ†æå“ªäº›æºæ–‡ä»¶å ç”¨ç©ºé—´æœ€å¤§
- å¯ä»¥è¯†åˆ«ä¸å¿…è¦çš„ä¾èµ– (æ¯”å¦‚å¼•å…¥äº†æ•´ä¸ª lodash ä½†åªç”¨äº†ä¸€ä¸ªå‡½æ•°)
- å¯ä»¥æŒ‰åŒ…åèšåˆ,ç»Ÿè®¡ç¬¬ä¸‰æ–¹åº“çš„å®é™…å ç”¨ (å¦‚ react å  150 KB)

---

### ğŸ§© Chunks (ä»£ç å—)

**æ˜¯ä»€ä¹ˆ**: æ‰“åŒ…å™¨å°† modules ç»„åˆè€Œæˆçš„ä¸­é—´äº§ç‰©,ä¸€ä¸ª chunk é€šå¸¸ä¼šç”Ÿæˆä¸€ä¸ª assetã€‚

**ä¸¾ä¾‹**:
- `main` chunk - åŒ…å«å…¥å£æ¨¡å—å’Œå®ƒçš„ä¾èµ–,æœ€ç»ˆç”Ÿæˆ `main.js`
- `vendor` chunk - åŒ…å«æ‰€æœ‰ node_modules,æœ€ç»ˆç”Ÿæˆ `vendor.js`
- `lazy-page` chunk - æŒ‰éœ€åŠ è½½çš„é¡µé¢,æœ€ç»ˆç”Ÿæˆ `lazy-page.js`

**ä¸ºä»€ä¹ˆé‡è¦**:
- ä½“ç°ä»£ç åˆ†å‰² (code splitting) çš„æ•ˆæœ
- å¯ä»¥åˆ†æ chunk çš„åˆ’åˆ†æ˜¯å¦åˆç†
- å¯ä»¥æ£€æµ‹é‡å¤æ¨¡å— (åŒä¸€ä¸ª module å‡ºç°åœ¨å¤šä¸ª chunks ä¸­)

---

### ğŸ”— ä¸‰è€…çš„å…³ç³»

```
æºä»£ç å±‚ (å¼€å‘æ—¶)        æ‰“åŒ…å±‚ (æ„å»ºä¸­)       è¾“å‡ºå±‚ (éƒ¨ç½²æ—¶)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Module 1   â”‚â”€â”€â”€â”€â”    â”‚             â”‚      â”‚             â”‚
â”‚ (index.js)  â”‚    â”‚    â”‚   Chunk 1   â”‚â”€â”€â”€â”€â”€â–¶â”‚  Asset 1    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”œâ”€â”€â”€â–¶â”‚   (main)    â”‚      â”‚ (main.js)   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚             â”‚      â”‚             â”‚
â”‚  Module 2   â”‚â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ (Button.jsx)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚             â”‚      â”‚             â”‚
â”‚  Module 3   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   Chunk 2   â”‚â”€â”€â”€â”€â”€â–¶â”‚  Asset 2    â”‚
â”‚ (react)     â”‚         â”‚  (vendor)   â”‚      â”‚(vendor.js)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚             â”‚      â”‚             â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ•°æ®æµ**:
1. **Module** (æºæ–‡ä»¶) â†’ è¢«æ‰“åŒ…å™¨è¯»å–å’Œè§£æ
2. **Chunk** (ä»£ç å—) â†’ æ ¹æ®å…¥å£å’Œåˆ†å‰²ç­–ç•¥ç»„åˆ modules
3. **Asset** (è¾“å‡ºæ–‡ä»¶) â†’ ä» chunk ç”Ÿæˆæœ€ç»ˆæ–‡ä»¶å¹¶å†™å…¥ç£ç›˜

**å…³é”®å…³ç³»**:
- **ä¸€ä¸ª Module å¯ä»¥å±äºå¤šä¸ª Chunks** (é‡å¤æ‰“åŒ…é—®é¢˜çš„æ ¹æº)
- **ä¸€ä¸ª Chunk åŒ…å«å¤šä¸ª Modules** (èšåˆå…³ç³»)
- **ä¸€ä¸ª Chunk é€šå¸¸ç”Ÿæˆä¸€ä¸ª Asset** (1:1 æ˜ å°„)
- **ä¸€ä¸ª Asset å¯èƒ½å…³è”å¤šä¸ª Chunks** (å¦‚ source map æ–‡ä»¶)

---

### ğŸ¯ ç”¨æˆ·ä¸ºä»€ä¹ˆéœ€è¦å…³æ³¨è¿™äº›æ•°æ®?

#### 1ï¸âƒ£ **ä¼˜åŒ–æ‰“åŒ…ä½“ç§¯** - é€šè¿‡ Modules åˆ†æ
- **é—®é¢˜**: æ‰“åŒ…åä½“ç§¯è¿‡å¤§,å½±å“åŠ è½½é€Ÿåº¦
- **åˆ†æè·¯å¾„**:
  - æŸ¥çœ‹å“ªäº› modules å ç”¨æœ€å¤§
  - æŒ‰åŒ…åèšåˆ,æ‰¾å‡ºæœ€é‡çš„ç¬¬ä¸‰æ–¹åº“
  - è¯„ä¼°æ˜¯å¦å¯ä»¥æ›¿æ¢æˆ–æŒ‰éœ€å¼•å…¥

**å®é™…æ¡ˆä¾‹**:
```
å‘ç° moment.js å  500 KB â†’ æ›¿æ¢ä¸º day.js åªå  2 KB
å‘ç°å¼•å…¥äº†æ•´ä¸ª lodash â†’ æ”¹ä¸ºæŒ‰éœ€å¼•å…¥ lodash-es
```

#### 2ï¸âƒ£ **æ£€æµ‹é‡å¤æ‰“åŒ…** - é€šè¿‡ Chunks å’Œ Modules å…³ç³»
- **é—®é¢˜**: åŒä¸€ä¸ª module è¢«æ‰“åŒ…åˆ°å¤šä¸ª chunks,æµªè´¹ç©ºé—´
- **åˆ†æè·¯å¾„**:
  - ç»Ÿè®¡å“ªäº› modules å‡ºç°åœ¨å¤šä¸ª chunks ä¸­
  - è®¡ç®—æµªè´¹çš„å¤§å° = module.size Ã— (å‡ºç°æ¬¡æ•° - 1)
  - è°ƒæ•´ splitChunks é…ç½®,æŠ½å–å…¬å…±æ¨¡å—

**å®é™…æ¡ˆä¾‹**:
```
React åŒæ—¶å‡ºç°åœ¨ main.js å’Œ page1.js ä¸­
â†’ é…ç½® splitChunks æŠ½å–åˆ° vendor.js
â†’ èŠ‚çœ 150 KB é‡å¤ä½“ç§¯
```

#### 3ï¸âƒ£ **éªŒè¯ä»£ç åˆ†å‰²æ•ˆæœ** - é€šè¿‡ Chunks å’Œ Assets
- **é—®é¢˜**: ä¸ç¡®å®šæ‡’åŠ è½½/æŒ‰éœ€åŠ è½½æ˜¯å¦ç”Ÿæ•ˆ
- **åˆ†æè·¯å¾„**:
  - æŸ¥çœ‹æ˜¯å¦ç”Ÿæˆäº†é¢„æœŸçš„ lazy chunks
  - æ£€æŸ¥ chunk å¤§å°æ˜¯å¦åˆç† (ä¸å®œè¿‡å¤§æˆ–è¿‡å°)
  - éªŒè¯ initial chunks æ•°é‡æ˜¯å¦ç¬¦åˆé¢„æœŸ

**å®é™…æ¡ˆä¾‹**:
```
é…ç½®äº†è·¯ç”±æ‡’åŠ è½½,ä½†åªçœ‹åˆ°ä¸€ä¸ª main.js
â†’ æ£€æŸ¥å‘ç°é…ç½®é”™è¯¯,ä¿®æ”¹åç”Ÿæˆäº†å¤šä¸ª lazy-*.js
â†’ é¦–å±åŠ è½½ä» 2MB é™åˆ° 500KB
```

#### 4ï¸âƒ£ **åˆ¶å®šæ€§èƒ½é¢„ç®—** - é€šè¿‡ Assets
- **é—®é¢˜**: éœ€è¦æ§åˆ¶èµ„æºå¤§å°,é¿å…è¶…æ ‡
- **åˆ†æè·¯å¾„**:
  - ç»Ÿè®¡æ¯ä¸ª asset çš„å¤§å°
  - å¯¹æ¯”æ€§èƒ½é¢„ç®—é˜ˆå€¼ (å¦‚ä¸» bundle < 200KB)
  - åœ¨ CI/CD ä¸­è®¾ç½®æ€§èƒ½é—¨ç¦

**å®é™…æ¡ˆä¾‹**:
```
è®¾ç½®è§„åˆ™: main.js ä¸èƒ½è¶…è¿‡ 300KB
â†’ æ¯æ¬¡æ„å»ºè‡ªåŠ¨æ£€æŸ¥
â†’ è¶…æ ‡æ—¶æ„å»ºå¤±è´¥å¹¶æç¤ºä¼˜åŒ–
```

#### 5ï¸âƒ£ **å¯è§†åŒ–ä¾èµ–å…³ç³»** - ç»¼åˆä¸‰è€…
- **é—®é¢˜**: ä¸æ¸…æ¥šä»£ç ä¹‹é—´çš„ä¾èµ–å…³ç³»å’Œæ‰“åŒ…ç»“æ„
- **åˆ†æè·¯å¾„**:
  - ç”Ÿæˆæ ‘çŠ¶å›¾ (treemap),æŒ‰å±‚çº§å±•ç¤º modules
  - æŒ‰é¢œè‰²åŒºåˆ†æ–‡ä»¶ç±»å‹ (JS/CSS/å›¾ç‰‡)
  - å¯äº¤äº’æŸ¥çœ‹æ¯ä¸ª module å±äºå“ªäº› chunks

**å®é™…ä»·å€¼**:
```
ç›´è§‚çœ‹åˆ° node_modules å äº† 80% ä½“ç§¯
ç‚¹å‡»æŸä¸ªå¤§æ–‡ä»¶,æŸ¥çœ‹æ˜¯å“ªä¸ª module å¼•å…¥çš„
è¿½æº¯ä¾èµ–é“¾,æ‰¾åˆ°ä¼˜åŒ–åˆ‡å…¥ç‚¹
```

---

## è®¾è®¡å“²å­¦

å‡è®¾ä½ ä¸€è¡Œä»£ç éƒ½æ²¡å†™ï¼Œæˆ‘ä»¬ä»é›¶å¼€å§‹æ€è€ƒï¼š**ä¸€ä¸ª Bundle Analyzer æ’ä»¶çš„æ ¸å¿ƒä»·å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

ç­”æ¡ˆæ˜¯ï¼š**å¸®åŠ©å¼€å‘è€…å›ç­”è¿™äº›é—®é¢˜**

- æˆ‘çš„æ‰“åŒ…äº§ç‰©æœ‰å¤šå¤§ï¼Ÿ
- å“ªäº›æ–‡ä»¶/æ¨¡å—å ç”¨äº†æœ€å¤šç©ºé—´ï¼Ÿ
- æˆ‘å¼•å…¥çš„ç¬¬ä¸‰æ–¹åº“ï¼ˆnode_modulesï¼‰å„è‡ªå ç”¨å¤šå¤§ï¼Ÿ
- ä»£ç åˆ†å‰²ï¼ˆcode splittingï¼‰æ˜¯å¦ç”Ÿæ•ˆï¼Ÿ
- æœ‰æ²¡æœ‰é‡å¤æ‰“åŒ…çš„æ¨¡å—ï¼Ÿ

åŸºäºè¿™ä¸ªæ€è·¯ï¼Œæˆ‘è®¤ä¸ºè¿™ä¸ªæ’ä»¶åº”è¯¥æ˜¯ä¸€ä¸ª**æ•°æ®æ”¶é›†å™¨ + åˆ†æå™¨**ï¼Œå®ƒçš„è¾“å‡ºåº”è¯¥èƒ½å¤Ÿï¼š

1. ç›´æ¥é˜…è¯»ï¼ˆJSON æ ¼å¼ï¼‰
2. å¯è§†åŒ–å±•ç¤ºï¼ˆæä¾›ç»™å‰ç«¯ï¼‰
3. é›†æˆåˆ° CI/CDï¼ˆæ€§èƒ½é—¨ç¦ï¼‰

---

## æ ¸å¿ƒåŠŸèƒ½è®¾è®¡

### é˜¶æ®µä¸€ï¼šæœ€å°å¯ç”¨ç‰ˆæœ¬ï¼ˆMVPï¼‰

**ç›®æ ‡**ï¼šå®ç°ä¸€ä¸ªèƒ½ç”¨çš„ç‰ˆæœ¬ï¼Œè¾“å‡ºå¯è¯»çš„åˆ†ææŠ¥å‘Š

#### åŠŸèƒ½ 1.1ï¼šåŸºç¡€æ•°æ®æ”¶é›†

**è¦æ”¶é›†ä»€ä¹ˆï¼Ÿ**

```rust
// æ ¸å¿ƒæ•°æ®ç»“æ„
struct BundleReport {
  // å…ƒæ•°æ®
  timestamp: u64,
  rspack_version: String,

  // æ€»è§ˆ
  summary: Summary,

  // èµ„äº§ï¼ˆæœ€ç»ˆè¾“å‡ºçš„æ–‡ä»¶ï¼‰
  assets: Vec<Asset>,

  // æ¨¡å—ï¼ˆæºä»£ç æ–‡ä»¶ï¼‰
  modules: Vec<Module>,

  // ä»£ç å—
  chunks: Vec<Chunk>,
}

struct Summary {
  total_size: u64,        // æ€»å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  total_assets: usize,    // è¾“å‡ºæ–‡ä»¶æ•°é‡
  total_modules: usize,   // æ¨¡å—æ•°é‡
  total_chunks: usize,    // chunk æ•°é‡
  build_time: f64,        // æ„å»ºè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
}

struct Asset {
  name: String,           // æ–‡ä»¶åï¼Œå¦‚ "main.js"
  size: usize,            // æ–‡ä»¶å¤§å°(æ³¨æ„:å®é™…ä»£ç ä¸­æ˜¯ usize,ä¸æ˜¯ u64)
  chunks: Vec<String>,    // å…³è”çš„ chunk
  emitted: bool,          // æ˜¯å¦å®é™…è¾“å‡º
}

struct Module {
  id: String,             // æ¨¡å—å”¯ä¸€ ID
  name: String,           // å¯è¯»åç§°ï¼Œå¦‚ "./src/index.js"
  size: u64,              // æ¨¡å—å¤§å°
  chunks: Vec<String>,    // åŒ…å«æ­¤æ¨¡å—çš„ chunks
}

struct Chunk {
  id: String,             // chunk ID
  names: Vec<String>,     // chunk åç§°
  size: u64,              // chunk å¤§å°
  modules: Vec<String>,   // åŒ…å«çš„æ¨¡å— ID åˆ—è¡¨
  entry: bool,            // æ˜¯å¦å…¥å£ chunk
  initial: bool,          // æ˜¯å¦åˆå§‹ chunk
}

struct Package {
  name: String,           // åŒ…å,å¦‚ "react" æˆ– "@babel/core"
  version: String,        // ç‰ˆæœ¬å·,æš‚æ—¶å›ºå®šä¸º "unknown"
  size: u64,              // è¯¥åŒ…çš„æ€»å¤§å°
  module_count: usize,    // åŒ…å«çš„æ¨¡å—æ•°é‡
  modules: Vec<String>,   // è¯¥åŒ…åŒ…å«çš„æ‰€æœ‰æ¨¡å— ID åˆ—è¡¨
}
```

**å®ç°è¦ç‚¹**ï¼š

```rust
// åœ¨ after_emit hook ä¸­æ”¶é›†æ•°æ®
async fn after_emit(&self, compilation: &mut Compilation) -> Result<()> {
  let start = Instant::now();

  // 1. æ”¶é›† Assetsï¼ˆè¾“å‡ºæ–‡ä»¶ï¼‰
  let assets = collect_assets(compilation);

  // 2. æ”¶é›† Modulesï¼ˆæºæ–‡ä»¶ï¼‰
  let modules = collect_modules(compilation);

  // 3. æ”¶é›† Chunksï¼ˆä»£ç å—ï¼‰
  let chunks = collect_chunks(compilation);

  // 4. åˆ†æ Packagesï¼ˆæŒ‰åŒ…åèšåˆï¼‰
  let packages = analyze_packages(&modules);

  // 5. ç”Ÿæˆæ‘˜è¦
  let summary = Summary {
    total_size: assets.iter().map(|a| a.size).sum(),
    total_assets: assets.len(),
    total_modules: modules.len(),
    total_chunks: chunks.len(),
    build_time: start.elapsed().as_millis() as f64,
  };

  // 6. æ„å»ºæŠ¥å‘Š
  let report = BundleReport {
    timestamp: current_timestamp(),
    rspack_version: get_rspack_version(),
    summary,
    assets,
    modules,
    chunks,
    packages,
  };

  // 7. è¾“å‡ºæŠ¥å‘Š
  output_report(&report, &self.options);

  Ok(())
}
```

**å…³é”®å®ç°**ï¼š

```rust
fn collect_assets(compilation: &Compilation) -> Vec<Asset> {
  compilation
    .assets()
    .iter()
    .map(|(name, asset)| {
      // æ³¨æ„:éœ€è¦æ£€æŸ¥ source æ˜¯å¦å­˜åœ¨,é¿å… panic
      let size = if let Some(source) = &asset.source {
        source.size()
      } else {
        0
      };

      Asset {
        name: name.to_string(),
        size: size,  // ç›´æ¥ä½¿ç”¨ usize,ä¸éœ€è¦ as u64
        chunks: get_asset_chunks(name, compilation),
        emitted: true,
      }
    })
    .collect()
}

fn collect_modules(compilation: &Compilation) -> Vec<Module> {
  let module_graph = compilation.get_module_graph();
  let chunk_graph = &compilation.chunk_graph;

  module_graph
    .modules()
    .into_iter()  // æ³¨æ„:å®é™…ä»£ç ä½¿ç”¨ into_iter(),ä¸æ˜¯ map()
    .map(|(id, module)| Module {
      id: id.to_string(),
      name: module
        .readable_identifier(&compilation.options.context)
        .to_string(),
      size: get_module_size(module.as_ref()),
      chunks: get_module_chunks(&id, chunk_graph),  // æ³¨æ„:ä¼ å…¥çš„æ˜¯ &id
    })
    .collect()
}

fn collect_chunks(compilation: &Compilation) -> Vec<Chunk> {
  let chunk_graph = &compilation.chunk_graph;
  let module_graph = compilation.get_module_graph();

  compilation
    .chunk_by_ukey
    .iter()
    .map(|(ukey, chunk)| {
      let modules: Vec<String> = chunk_graph  // æ³¨æ„:æ·»åŠ äº†ç±»å‹æ ‡æ³¨
        .get_chunk_modules(ukey, &module_graph)
        .iter()
        .map(|m| m.identifier().to_string())
        .collect();

      Chunk {
        id: ukey.as_u32().to_string(),
        names: chunk
          .name()
          .map(|n| vec![n.to_string()])
          .unwrap_or_default(),
        size: calculate_chunk_size(&modules, &module_graph),
        modules,
        entry: chunk.has_entry_module(chunk_graph),
        // æ³¨æ„:å®é™…ä»£ç ä¼ å…¥çš„æ˜¯ &compilation.chunk_group_by_ukey,ä¸æ˜¯ chunk_graph
        initial: chunk.can_be_initial(&compilation.chunk_group_by_ukey),
      }
    })
    .collect()
}

// è·å–æ¨¡å—çœŸå®å¤§å°
fn get_module_size(module: &dyn Module) -> u64 {
  // æ³¨æ„:å®é™…ä»£ç ä½¿ç”¨ Module trait çš„ size æ–¹æ³•,ä¸æ˜¯ original_source()
  // source_type å‚æ•°ä¸º None è¡¨ç¤ºè·å–æ‰€æœ‰ç±»å‹çš„æ€»å¤§å°
  // compilation å‚æ•°ä¸º None å› ä¸ºæˆ‘ä»¬ä¸éœ€è¦ç¼–è¯‘ä¸Šä¸‹æ–‡
  module.size(None, None) as u64
}

// åˆ†æåŒ…ä¾èµ–,æŒ‰åŒ…åèšåˆ
fn analyze_packages(modules: &[Module]) -> Vec<Package> {
  use std::collections::HashMap;

  let mut package_map: HashMap<String, Vec<&Module>> = HashMap::new();

  // 1. éå†æ‰€æœ‰æ¨¡å—,æŒ‰åŒ…ååˆ†ç»„
  for module in modules {
    if let Some(package_name) = parse_package_name(&module.name) {
      package_map.entry(package_name).or_default().push(module);
    }
  }

  // 2. ä¸ºæ¯ä¸ªåŒ…ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
  let mut packages: Vec<Package> = package_map
    .into_iter()
    .map(|(name, mods)| {
      let size: u64 = mods.iter().map(|m| m.size).sum();
      let modules: Vec<String> = mods.iter().map(|m| m.id.clone()).collect();

      Package {
        name,
        version: "unknown".to_string(),  // æš‚æ—¶å›ºå®šä¸º unknown
        size,
        module_count: mods.len(),
        modules,
      }
    })
    .collect();

  // 3. æŒ‰å¤§å°é™åºæ’åº
  packages.sort_by_key(|p| std::cmp::Reverse(p.size));

  packages
}

// ä»æ¨¡å—è·¯å¾„ä¸­è§£æåŒ…å
// ä¾‹å¦‚:
//   "node_modules/react/index.js" -> Some("react")
//   "node_modules/@babel/core/lib.js" -> Some("@babel/core")
//   "./src/index.js" -> None (ä¸æ˜¯ node_modules)
fn parse_package_name(module_path: &str) -> Option<String> {
  // åªå¤„ç† node_modules ä¸­çš„æ¨¡å—
  if !module_path.contains("node_modules/") {
    return None;
  }

  // æ‰¾åˆ° node_modules/ åé¢çš„éƒ¨åˆ†
  let parts: Vec<&str> = module_path.split("node_modules/").collect();
  if parts.len() < 2 {
    return None;
  }

  let after_nm = parts[1];
  let segments: Vec<&str> = after_nm.split('/').collect();

  // å¤„ç† scoped package (å¦‚ @babel/core)
  if segments[0].starts_with('@') {
    if segments.len() < 2 {
      return None;
    }
    Some(format!("{}/{}", segments[0], segments[1]))
  } else {
    // æ™®é€š package (å¦‚ react)
    Some(segments[0].to_string())
  }
}
```

**è¾“å‡ºæ ¼å¼**ï¼š

```rust
fn output_report(report: &BundleReport, options: &PluginOptions) {
  // 1. è¾“å‡º JSON æ–‡ä»¶
  if let Some(path) = &options.report_filename {
    let json = serde_json::to_string_pretty(report).unwrap();
    std::fs::write(path, json).unwrap();
    println!("ğŸ“Š Bundle analysis saved to: {}", path);
  }

  // 2. è°ƒç”¨å›è°ƒ
  if let Some(callback) = &options.on_analyzed {
    callback(report.clone()).await;
  }
}
```

---

#### åŠŸèƒ½ 1.2ï¼šç®€å•çš„ç»ˆç«¯è¾“å‡º

**ç›®æ ‡**ï¼šæ„å»ºå®Œæˆåç›´æ¥åœ¨ç»ˆç«¯æ˜¾ç¤ºå…³é”®ä¿¡æ¯

```rust
fn print_summary(report: &BundleReport) {
  use byte_unit::{Byte, UnitType};

  println!("\nğŸ“¦ Bundle Analysis Summary");
  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

  let total = Byte::from_u64(report.summary.total_size);
  println!("Total Size:    {}", total.get_appropriate_unit(UnitType::Binary));
  println!("Assets:        {}", report.summary.total_assets);
  println!("Modules:       {}", report.summary.total_modules);
  println!("Chunks:        {}", report.summary.total_chunks);
  println!("Build Time:    {:.2}ms", report.summary.build_time);

  println!("\nğŸ“„ Largest Assets:");
  let mut assets = report.assets.clone();
  assets.sort_by_key(|a| std::cmp::Reverse(a.size));

  for asset in assets.iter().take(5) {
    let size = Byte::from_u64(asset.size);
    println!("  {} - {}", asset.name, size.get_appropriate_unit(UnitType::Binary));
  }

  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
}
```

---

### é˜¶æ®µäºŒï¼šæ·±åº¦åˆ†æ

**ç›®æ ‡**ï¼šæä¾›æ›´æœ‰ä»·å€¼çš„åˆ†ææ•°æ®

#### åŠŸèƒ½ 2.1ï¼šä¾èµ–åŒ…åˆ†æï¼ˆæœ€å®ç”¨ï¼ï¼‰

**ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ**

- node_modules é€šå¸¸å ç”¨ 70%+ çš„ä½“ç§¯
- å¼€å‘è€…éœ€è¦çŸ¥é“å“ªä¸ªåŒ…æœ€é‡ï¼Œè€ƒè™‘æ˜¯å¦æ›¿æ¢

**æ•°æ®ç»“æ„**ï¼š

```rust
struct PackageAnalysis {
  packages: Vec<PackageInfo>,
  total_size: u64,
  total_count: usize,
}

struct PackageInfo {
  name: String,              // åŒ…åï¼Œå¦‚ "react"
  version: String,           // ç‰ˆæœ¬ï¼Œå¦‚ "18.2.0"
  size: u64,                 // å ç”¨å¤§å°
  module_count: usize,       // åŒ…å«çš„æ¨¡å—æ•°
  modules: Vec<String>,      // æ¨¡å—è·¯å¾„åˆ—è¡¨
  main_fields: Vec<String>,  // å®é™…ä½¿ç”¨çš„å…¥å£
}
```

**å®ç°æ€è·¯**ï¼š

```rust
fn analyze_packages(modules: &[Module]) -> PackageAnalysis {
  let mut package_map: HashMap<String, Vec<&Module>> = HashMap::new();

  // 1. åˆ†ç»„ï¼šæŒ‰åŒ…åèšåˆæ¨¡å—
  for module in modules {
    if let Some((package_name, _)) = parse_package_path(&module.name) {
      package_map.entry(package_name).or_default().push(module);
    }
  }

  // 2. ç»Ÿè®¡æ¯ä¸ªåŒ…çš„ä¿¡æ¯
  let mut packages: Vec<PackageInfo> = package_map
    .into_iter()
    .map(|(name, mods)| {
      let version = resolve_package_version(&name);  // ä» package.json è¯»å–
      let size = mods.iter().map(|m| m.size).sum();

      PackageInfo {
        name: name.clone(),
        version,
        size,
        module_count: mods.len(),
        modules: mods.iter().map(|m| m.name.clone()).collect(),
        main_fields: vec![], // å¯é€‰
      }
    })
    .collect();

  // 3. æŒ‰å¤§å°æ’åº
  packages.sort_by_key(|p| std::cmp::Reverse(p.size));

  PackageAnalysis {
    total_size: packages.iter().map(|p| p.size).sum(),
    total_count: packages.len(),
    packages,
  }
}

// è§£æåŒ…è·¯å¾„
// "node_modules/react/index.js" -> ("react", "index.js")
// "node_modules/@babel/core/lib/index.js" -> ("@babel/core", "lib/index.js")
fn parse_package_path(path: &str) -> Option<(String, String)> {
  let parts: Vec<&str> = path.split("node_modules/").collect();
  if parts.len() < 2 {
    return None;
  }

  let after_nm = parts[1];
  let segments: Vec<&str> = after_nm.split('/').collect();

  let (pkg_name, rest) = if segments[0].starts_with('@') {
    // scoped package: @babel/core
    let name = format!("{}/{}", segments[0], segments.get(1)?);
    let rest = segments[2..].join("/");
    (name, rest)
  } else {
    // normal package: react
    let name = segments[0].to_string();
    let rest = segments[1..].join("/");
    (name, rest)
  };

  Some((pkg_name, rest))
}

// è¯»å– package.json è·å–ç‰ˆæœ¬
fn resolve_package_version(package_name: &str) -> String {
  // 1. ä»é¡¹ç›®æ ¹ç›®å½•å¼€å§‹æŸ¥æ‰¾
  // 2. è¯»å– node_modules/{package_name}/package.json
  // 3. è§£æ version å­—æ®µ

  // ç®€åŒ–å®ç°
  "unknown".to_string()
}
```

**ç»ˆç«¯è¾“å‡º**ï¼š

```rust
fn print_package_analysis(analysis: &PackageAnalysis) {
  use byte_unit::{Byte, UnitType};

  println!("\nğŸ“¦ Top 10 Packages by Size:");
  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

  for (i, pkg) in analysis.packages.iter().take(10).enumerate() {
    let size = Byte::from_u64(pkg.size);
    let percentage = (pkg.size as f64 / analysis.total_size as f64) * 100.0;

    println!(
      "{:2}. {:30} {:>10} ({:>5.1}%) - {} modules",
      i + 1,
      format!("{}@{}", pkg.name, pkg.version),
      size.get_appropriate_unit(UnitType::Binary).to_string(),
      percentage,
      pkg.module_count
    );
  }

  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
}
```

---

#### åŠŸèƒ½ 2.2ï¼šé‡å¤æ¨¡å—æ£€æµ‹

**ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ**

- åŒä¸€ä¸ªæ¨¡å—è¢«å¤šä¸ª chunk åŒ…å« = æµªè´¹ç©ºé—´
- åº”è¯¥æŠ½å–åˆ°å…¬å…± chunk

**æ•°æ®ç»“æ„**ï¼š

```rust
struct DuplicateAnalysis {
  duplicates: Vec<DuplicateModule>,
  wasted_size: u64,  // æµªè´¹çš„æ€»å¤§å°
}

struct DuplicateModule {
  module_id: String,
  module_name: String,
  size: u64,
  occurrences: usize,     // å‡ºç°æ¬¡æ•°
  chunks: Vec<String>,    // åŒ…å«å®ƒçš„ chunks
  wasted_size: u64,       // æµªè´¹çš„å¤§å° = size * (occurrences - 1)
}
```

**å®ç°**ï¼š

```rust
fn detect_duplicates(modules: &[Module], chunks: &[Chunk]) -> DuplicateAnalysis {
  // 1. ç»Ÿè®¡æ¯ä¸ªæ¨¡å—å‡ºç°åœ¨å¤šå°‘ä¸ª chunk ä¸­
  let mut module_chunks: HashMap<String, Vec<String>> = HashMap::new();

  for chunk in chunks {
    for module_id in &chunk.modules {
      module_chunks
        .entry(module_id.clone())
        .or_default()
        .push(chunk.id.clone());
    }
  }

  // 2. æ‰¾å‡ºé‡å¤çš„æ¨¡å—ï¼ˆå‡ºç°åœ¨ 2+ chunksï¼‰
  let duplicates: Vec<DuplicateModule> = module_chunks
    .into_iter()
    .filter(|(_, chunks)| chunks.len() > 1)
    .filter_map(|(module_id, chunks)| {
      let module = modules.iter().find(|m| m.id == module_id)?;
      let occurrences = chunks.len();
      let wasted = module.size * (occurrences as u64 - 1);

      Some(DuplicateModule {
        module_id: module_id.clone(),
        module_name: module.name.clone(),
        size: module.size,
        occurrences,
        chunks,
        wasted_size: wasted,
      })
    })
    .collect();

  let wasted_size = duplicates.iter().map(|d| d.wasted_size).sum();

  DuplicateAnalysis {
    duplicates,
    wasted_size,
  }
}
```

**ç»ˆç«¯è¾“å‡º**ï¼š

```rust
fn print_duplicate_analysis(analysis: &DuplicateAnalysis) {
  if analysis.duplicates.is_empty() {
    println!("âœ… No duplicate modules found!");
    return;
  }

  use byte_unit::{Byte, UnitType};

  println!("\nâš ï¸  Duplicate Modules Detected:");
  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  println!(
    "Total wasted: {}",
    Byte::from_u64(analysis.wasted_size).get_appropriate_unit(UnitType::Binary)
  );

  let mut sorted = analysis.duplicates.clone();
  sorted.sort_by_key(|d| std::cmp::Reverse(d.wasted_size));

  for dup in sorted.iter().take(10) {
    let size = Byte::from_u64(dup.size);
    let wasted = Byte::from_u64(dup.wasted_size);

    println!(
      "\n  {} ({} -> wasted: {})",
      dup.module_name,
      size.get_appropriate_unit(UnitType::Binary),
      wasted.get_appropriate_unit(UnitType::Binary)
    );
    println!("  Appears in {} chunks: {:?}", dup.occurrences, dup.chunks);
  }

  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
}
```

---

### é˜¶æ®µä¸‰ï¼šå¯è§†åŒ–æ”¯æŒ

**ç›®æ ‡**ï¼šç”Ÿæˆå‰ç«¯å¯ç›´æ¥ä½¿ç”¨çš„æ•°æ®æ ¼å¼

#### åŠŸèƒ½ 3.1ï¼šæ ‘çŠ¶å›¾æ•°æ®ï¼ˆTreemapï¼‰

**ç”¨é€”**ï¼šç”¨äº echarts/d3.js ç»˜åˆ¶æ ‘çŠ¶å›¾

```rust
struct TreemapData {
  name: String,
  value: u64,              // å¤§å°
  children: Vec<TreemapData>,
  path: Option<String>,    // å®Œæ•´è·¯å¾„
  item_style: Option<ItemStyle>,
}

struct ItemStyle {
  color: String,  // æ ¹æ®ç±»å‹ç€è‰²
}

fn generate_treemap(modules: &[Module]) -> TreemapData {
  let mut root = TreemapNode::new("root");

  // æŒ‰è·¯å¾„æ„å»ºæ ‘
  for module in modules {
    insert_module_into_tree(&mut root, module);
  }

  build_treemap_data(root)
}

struct TreemapNode {
  name: String,
  size: u64,
  children: HashMap<String, TreemapNode>,
  is_leaf: bool,
  module_type: Option<String>,
}

fn insert_module_into_tree(root: &mut TreemapNode, module: &Module) {
  let path = &module.name;
  let segments: Vec<&str> = path.split('/').filter(|s| !s.is_empty()).collect();

  let mut current = root;

  for (i, segment) in segments.iter().enumerate() {
    let is_last = i == segments.len() - 1;

    current.size += module.size;

    if is_last {
      // å¶å­èŠ‚ç‚¹
      let mut leaf = TreemapNode::new(segment);
      leaf.size = module.size;
      leaf.is_leaf = true;
      leaf.module_type = Some(detect_module_type(path));
      current.children.insert(segment.to_string(), leaf);
    } else {
      // ä¸­é—´èŠ‚ç‚¹
      current = current
        .children
        .entry(segment.to_string())
        .or_insert_with(|| TreemapNode::new(segment));
    }
  }
}

fn build_treemap_data(node: TreemapNode) -> TreemapData {
  let children: Vec<TreemapData> = node
    .children
    .into_iter()
    .map(|(_, child)| build_treemap_data(child))
    .collect();

  let color = if let Some(ref module_type) = node.module_type {
    get_color_for_type(module_type)
  } else {
    "#cccccc".to_string()
  };

  TreemapData {
    name: node.name,
    value: node.size,
    children,
    path: None,
    item_style: Some(ItemStyle { color }),
  }
}

fn get_color_for_type(module_type: &str) -> String {
  match module_type {
    "javascript" => "#f7df1e".to_string(),
    "typescript" => "#3178c6".to_string(),
    "css" => "#264de4".to_string(),
    "image" => "#4caf50".to_string(),
    "json" => "#000000".to_string(),
    _ => "#999999".to_string(),
  }
}

fn detect_module_type(path: &str) -> String {
  if path.ends_with(".ts") || path.ends_with(".tsx") {
    "typescript"
  } else if path.ends_with(".js") || path.ends_with(".jsx") {
    "javascript"
  } else if path.ends_with(".css") || path.ends_with(".scss") {
    "css"
  } else if path.ends_with(".png") || path.ends_with(".jpg") || path.ends_with(".svg") {
    "image"
  } else if path.ends_with(".json") {
    "json"
  } else {
    "other"
  }.to_string()
}
```

---

### é˜¶æ®µå››ï¼šé…ç½®ä¸è¾“å‡º

**ç›®æ ‡**ï¼šçµæ´»çš„é…ç½®é€‰é¡¹

```rust
pub struct BundleAnalyzerPluginOpts {
  // è¾“å‡ºé€‰é¡¹
  pub report_filename: Option<String>,  // JSON æŠ¥å‘Šè·¯å¾„
  pub open_analyzer: bool,              // æ˜¯å¦è‡ªåŠ¨æ‰“å¼€å¯è§†åŒ–é¡µé¢

  // åˆ†æé€‰é¡¹
  pub analyze_mode: AnalyzeMode,
  pub exclude_assets: Option<Vec<String>>,  // æ’é™¤çš„èµ„æºï¼ˆglobï¼‰
  pub stats_options: StatsOptions,

  // å›è°ƒ
  pub on_analyzed: Option<CompilationHookFn>,
}

pub enum AnalyzeMode {
  Full,      // å®Œæ•´åˆ†æï¼ˆåŒ…å«æ‰€æœ‰åŠŸèƒ½ï¼‰
  Static,    // åªç”Ÿæˆé™æ€æŠ¥å‘Š
  Disabled,  // ç¦ç”¨
}

pub struct StatsOptions {
  pub show_packages: bool,      // æ˜¯å¦åˆ†æ packages
  pub show_duplicates: bool,    // æ˜¯å¦æ£€æµ‹é‡å¤
  pub top_modules_count: usize, // æ˜¾ç¤º top N æ¨¡å—
}

impl Default for BundleAnalyzerPluginOpts {
  fn default() -> Self {
    Self {
      report_filename: Some("bundle-report.json".to_string()),
      open_analyzer: false,
      analyze_mode: AnalyzeMode::Full,
      exclude_assets: None,
      stats_options: StatsOptions {
        show_packages: true,
        show_duplicates: true,
        top_modules_count: 20,
      },
      on_analyzed: None,
    }
  }
}
```

---

## æœ€ç»ˆçš„æ•°æ®ç»“æ„

```rust
// æœ€ç»ˆè¾“å‡ºçš„å®Œæ•´æŠ¥å‘Š
#[derive(Serialize, Deserialize)]
pub struct BundleReport {
  // åŸºç¡€ä¿¡æ¯
  pub timestamp: u64,
  pub rspack_version: String,
  pub summary: Summary,

  // æ ¸å¿ƒæ•°æ®
  pub assets: Vec<Asset>,
  pub modules: Vec<Module>,
  pub chunks: Vec<Chunk>,

  // åˆ†æç»“æœ
  pub package_analysis: Option<PackageAnalysis>,
  pub duplicate_analysis: Option<DuplicateAnalysis>,

  // å¯è§†åŒ–æ•°æ®
  pub treemap_data: Option<TreemapData>,
}
```

---

## å®æ–½è®¡åˆ’

### ç¬¬ä¸€æ­¥ï¼šå®ç° MVPï¼ˆé˜¶æ®µä¸€ï¼‰

- [ ] å®šä¹‰åŸºç¡€æ•°æ®ç»“æ„ï¼ˆAssetã€Moduleã€Chunkã€Summaryï¼‰
- [ ] å®ç° `collect_assets()`
- [ ] å®ç° `collect_modules()`ï¼ˆå‡†ç¡®çš„å¤§å°è®¡ç®—ï¼‰
- [ ] å®ç° `collect_chunks()`
- [ ] å®ç° JSON è¾“å‡º
- [ ] å®ç°ç®€å•çš„ç»ˆç«¯æ‘˜è¦è¾“å‡º

**éªŒæ”¶æ ‡å‡†**ï¼š

- èƒ½è¾“å‡º bundle-report.json
- ç»ˆç«¯æ˜¾ç¤ºæ€»å¤§å°ã€æ–‡ä»¶æ•°ç­‰åŸºç¡€ä¿¡æ¯
- æ•°æ®å‡†ç¡®ï¼ˆå’Œå®é™…æ–‡ä»¶å¤§å°ä¸€è‡´ï¼‰

---

### ç¬¬äºŒæ­¥ï¼šæ·»åŠ æ·±åº¦åˆ†æï¼ˆé˜¶æ®µäºŒï¼‰

- [ ] å®ç°åŒ…åˆ†æï¼ˆ`analyze_packages()`ï¼‰
- [ ] å®ç° `parse_package_path()`
- [ ] å®ç° `resolve_package_version()`ï¼ˆè¯»å– package.jsonï¼‰
- [ ] å®ç°é‡å¤æ£€æµ‹ï¼ˆ`detect_duplicates()`ï¼‰
- [ ] ç¾åŒ–ç»ˆç«¯è¾“å‡º

**éªŒæ”¶æ ‡å‡†**ï¼š

- ç»ˆç«¯æ˜¾ç¤º Top 10 æœ€å¤§çš„åŒ…
- æ˜¾ç¤ºé‡å¤æ¨¡å—åŠæµªè´¹çš„ç©ºé—´
- æ•°æ®å¯è¯»æ€§å¥½

---

### ç¬¬ä¸‰æ­¥ï¼šå¯è§†åŒ–æ•°æ®ï¼ˆé˜¶æ®µä¸‰ï¼‰

- [ ] å®ç°æ ‘çŠ¶å›¾æ•°æ®ç”Ÿæˆ
- [ ] æ”¯æŒæŒ‰ç±»å‹ç€è‰²
- [ ] ï¼ˆå¯é€‰ï¼‰ç”Ÿæˆ HTML å¯è§†åŒ–é¡µé¢

**éªŒæ”¶æ ‡å‡†**ï¼š

- JSON ä¸­åŒ…å« treemap_data
- æ•°æ®å¯ä»¥ç›´æ¥ç”¨äº echarts

---

### ç¬¬å››æ­¥ï¼šå®Œå–„é…ç½®ï¼ˆé˜¶æ®µå››ï¼‰

- [ ] å®ç°é…ç½®é€‰é¡¹
- [ ] æ”¯æŒæ’é™¤æŸäº›èµ„æº
- [ ] æ”¯æŒä¸åŒçš„åˆ†ææ¨¡å¼

**éªŒæ”¶æ ‡å‡†**ï¼š

- é…ç½®çµæ´»å¯ç”¨
- æ–‡æ¡£å®Œå–„

---

## å…³é”®ä»£ç ç‰‡æ®µ

### å‡†ç¡®è·å–æ¨¡å—å¤§å°

```rust
fn get_module_size(module: &dyn Module) -> u64 {
  // å®é™…å®ç°:ä½¿ç”¨ Module trait çš„ size æ–¹æ³•
  // source_type å‚æ•°ä¸º None è¡¨ç¤ºè·å–æ‰€æœ‰ç±»å‹çš„æ€»å¤§å°
  // compilation å‚æ•°ä¸º None å› ä¸ºæˆ‘ä»¬ä¸éœ€è¦ç¼–è¯‘ä¸Šä¸‹æ–‡
  module.size(None, None) as u64
}
```

### è·å– Asset å…³è”çš„ Chunks

```rust
fn get_asset_chunks(asset_name: &str, compilation: &Compilation) -> Vec<String> {
  compilation
    .chunk_by_ukey
    .values()
    .filter(|chunk| chunk.files().contains(asset_name))  // å®é™…ä»£ç ä¸éœ€è¦ .into()
    .map(|chunk| {
      // å®é™…ä»£ç éœ€è¦å¤„ç† chunk.id() ä¸º None çš„æƒ…å†µ
      let id = if let Some(id) = chunk.id() {
        id.to_string()
      } else {
        "".to_string()
      };
      return id;
    })
    .collect()
}
```

### è·å– Module æ‰€åœ¨çš„ Chunks

```rust
fn get_module_chunks(module_id: &Identifier, chunk_graph: &ChunkGraph) -> Vec<String> {
  // æ³¨æ„:å®é™…ä»£ç ä¸­å‚æ•°ç±»å‹æ˜¯ &Identifier,ä¸æ˜¯ &ModuleIdentifier
  chunk_graph
    .get_module_chunks(*module_id)
    .iter()
    .map(|chunk_ukey| chunk_ukey.as_u32().to_string())
    .collect()
}
```

---

## æ€»ç»“

è¿™ä¸ªè®¾è®¡çš„æ ¸å¿ƒæ€è·¯ï¼š

1. **ä»ç®€å•å¼€å§‹**ï¼šå…ˆå®ç° MVPï¼Œä¿è¯æ•°æ®å‡†ç¡®
2. **é€æ­¥å¢å¼º**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½å¢åŠ ä¸€ä¸ªå®ç”¨åŠŸèƒ½
3. **æ³¨é‡å®ç”¨æ€§**ï¼šåŒ…åˆ†æã€é‡å¤æ£€æµ‹éƒ½æ˜¯çœŸæ­£æœ‰ç”¨çš„
4. **å¯è§†åŒ–å‹å¥½**ï¼šè¾“å‡ºçš„æ•°æ®å¯ä»¥ç›´æ¥ç”¨äºå‰ç«¯å±•ç¤º

å»ºè®®æŒ‰ç…§**ç¬¬ä¸€æ­¥ â†’ ç¬¬äºŒæ­¥ â†’ ç¬¬ä¸‰æ­¥ â†’ ç¬¬å››æ­¥**çš„é¡ºåºå®æ–½ï¼Œæ¯å®Œæˆä¸€æ­¥å°±æœ‰ä¸€ä¸ªå¯ç”¨çš„ç‰ˆæœ¬ã€‚
