# Bundle Analyzer Plugin 功能设计

## 概述

Bundle Analyzer Plugin 是一个用于分析 webpack/rspack 打包结果的插件，帮助开发者了解打包产物的结构、大小分布和依赖关系。

## 核心功能

### 1. 基本分析数据收集

插件会在构建完成后收集以下信息：

#### 模块信息 (Module Info)
- **模块标识符**: 模块的唯一标识
- **模块名称**: 可读的模块名称
- **模块路径**: 模块在文件系统中的路径
- **模块大小**: 
  - 原始大小 (original size)
  - 压缩后大小 (minified size)
  - gzip 压缩大小 (gzipped size)
- **模块类型**: JavaScript, CSS, 图片等
- **是否为入口模块**: 标识是否为入口点

#### 代码块信息 (Chunk Info)
- **代码块 ID**: 代码块的唯一标识
- **代码块名称**: 代码块的名称
- **代码块大小**: 包含的所有模块的总大小
- **包含的模块列表**: 该代码块包含的所有模块
- **是否为入口代码块**: 标识是否为入口代码块
- **父子代码块关系**: 代码块之间的依赖关系

#### 依赖关系 (Dependency Info)
- **模块依赖**: 每个模块依赖的其他模块
- **依赖类型**: import, require, 动态导入等
- **依赖路径**: 依赖的具体引用路径
- **是否为循环依赖**: 检测循环依赖情况

### 2. 统计信息

#### 全局统计
- **总模块数量**: 打包包含的模块总数
- **总代码块数量**: 生成的代码块总数
- **总大小统计**: 
  - 原始总大小
  - 压缩总大小
  - gzip 总大小
- **构建时间**: 分析耗时

#### 分类统计
- **按文件类型分组**: JavaScript, CSS, 图片等
- **按模块来源分组**: node_modules, 本地代码等
- **大小分布**: 大模块、小模块的分布情况

### 3. 热力图数据

为了支持可视化展示，提供：
- **树形结构数据**: 用于展示模块层级关系
- **大小映射**: 模块大小到可视化区域的映射
- **颜色编码**: 根据模块大小、类型等进行颜色编码

## API 设计

### 插件配置选项

```typescript
interface BundleAnalyzerPluginOptions {
  // 用户回调函数，接收分析结果
  onAnalyzed?: (result: BundleAnalysisResult) => Promise<void> | void;
  
  // 可选配置
  excludeModules?: string[]; // 排除的模块路径模式
  includeAssets?: boolean;   // 是否包含静态资源分析
  generateReport?: boolean;  // 是否生成 HTML 报告
  outputPath?: string;       // 报告输出路径
}
```

### 分析结果数据结构

```typescript
interface BundleAnalysisResult {
  // 基本信息
  timestamp: number;
  buildTime: number; // 构建时间（毫秒）
  
  // 全局统计
  summary: {
    totalModules: number;
    totalChunks: number;
    totalSize: SizeInfo;
  };
  
  // 模块详情
  modules: ModuleInfo[];
  
  // 代码块详情
  chunks: ChunkInfo[];
  
  // 依赖关系图
  dependencyGraph: DependencyNode[];
  
  // 分类统计
  statistics: {
    byFileType: Record<string, TypeStatistics>;
    bySource: Record<string, SourceStatistics>;
    largestModules: ModuleInfo[]; // 前10大模块
  };
  
  // 可视化数据
  visualization: {
    treeData: TreeNode[];
    heatmapData: HeatmapNode[];
  };
}

interface SizeInfo {
  original: number;   // 原始大小（字节）
  minified: number;   // 压缩大小（字节）
  gzipped: number;    // gzip 大小（字节）
}

interface ModuleInfo {
  id: string;
  name: string;
  path: string;
  size: SizeInfo;
  type: string; // 'javascript' | 'css' | 'image' | 'other'
  source: string; // 'node_modules' | 'src' | 'other'
  isEntry: boolean;
  dependencies: string[]; // 依赖的模块 ID 列表
}

interface ChunkInfo {
  id: string;
  name: string;
  size: SizeInfo;
  modules: string[]; // 包含的模块 ID 列表
  isEntry: boolean;
  parents: string[]; // 父代码块 ID
  children: string[]; // 子代码块 ID
}

interface DependencyNode {
  moduleId: string;
  dependencies: Array<{
    moduleId: string;
    type: string; // 'import' | 'require' | 'dynamic'
    userRequest: string;
  }>;
}

interface TreeNode {
  name: string;
  size: number;
  children?: TreeNode[];
  path?: string;
  type?: string;
}

interface HeatmapNode {
  name: string;
  value: number; // 大小值
  path: string;
  level: number; // 层级深度
}
```

## 使用示例

```typescript
import { BundleAnalyzerPlugin } from '@shined/spack-plugin-bundle-analyzer';

// 基本使用
const plugin = new BundleAnalyzerPlugin({
  onAnalyzed: async (result) => {
    console.log('Bundle Analysis Result:', result);
    
    // 输出摘要信息
    console.log(`Total modules: ${result.summary.totalModules}`);
    console.log(`Total size: ${result.summary.totalSize.original} bytes`);
    
    // 查找最大的模块
    const largestModule = result.statistics.largestModules[0];
    console.log(`Largest module: ${largestModule.name} (${largestModule.size.original} bytes)`);
    
    // 保存结果到文件
    await fs.writeFile('bundle-analysis.json', JSON.stringify(result, null, 2));
  }
});

// 高级配置
const advancedPlugin = new BundleAnalyzerPlugin({
  onAnalyzed: (result) => {
    // 自定义处理逻辑
    analyzeCircularDependencies(result);
    generateCustomReport(result);
    sendMetricsToServer(result);
  },
  excludeModules: ['**/node_modules/lodash/**'],
  includeAssets: true,
  generateReport: true,
  outputPath: './reports/bundle-analysis.html'
});
```

## 实现要点

### 1. 性能考虑
- 异步处理分析逻辑，避免阻塞构建过程
- 大型项目的内存优化
- 可配置的分析深度和范围

### 2. 数据准确性
- 准确计算模块大小（考虑 tree-shaking 效果）
- 正确识别模块间的依赖关系
- 处理动态导入的特殊情况

### 3. 扩展性
- 预留接口支持自定义分析规则
- 支持插件间的数据共享
- 便于与其他分析工具集成

### 4. 错误处理
- 优雅处理回调函数中的异常
- 提供详细的错误信息和调试日志
- 不影响正常的构建流程

## 后续扩展

1. **可视化界面**: 提供 Web 界面展示分析结果
2. **历史对比**: 支持多次构建结果的对比分析
3. **性能建议**: 基于分析结果提供优化建议
4. **集成告警**: 当包大小超过阈值时发送告警
5. **团队协作**: 支持分析结果的分享和协作功能