# Bundle Analyzer Plugin - å…¨æ–°åŠŸèƒ½è®¾è®¡

## è®¾è®¡å“²å­¦

å‡è®¾ä½ ä¸€è¡Œä»£ç éƒ½æ²¡å†™ï¼Œæˆ‘ä»¬ä»é›¶å¼€å§‹æ€è€ƒï¼š**ä¸€ä¸ª Bundle Analyzer æ’ä»¶çš„æ ¸å¿ƒä»·å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

ç­”æ¡ˆæ˜¯ï¼š**å¸®åŠ©å¼€å‘è€…å›ç­”è¿™äº›é—®é¢˜**

- æˆ‘çš„æ‰“åŒ…äº§ç‰©æœ‰å¤šå¤§ï¼Ÿ
- å“ªäº›æ–‡ä»¶/æ¨¡å—å ç”¨äº†æœ€å¤šç©ºé—´ï¼Ÿ
- æˆ‘å¼•å…¥çš„ç¬¬ä¸‰æ–¹åº“ï¼ˆnode_modulesï¼‰å„è‡ªå ç”¨å¤šå¤§ï¼Ÿ
- ä»£ç åˆ†å‰²ï¼ˆcode splittingï¼‰æ˜¯å¦ç”Ÿæ•ˆï¼Ÿ
- æœ‰æ²¡æœ‰é‡å¤æ‰“åŒ…çš„æ¨¡å—ï¼Ÿ

åŸºäºè¿™ä¸ªæ€è·¯ï¼Œæˆ‘è®¤ä¸ºè¿™ä¸ªæ’ä»¶åº”è¯¥æ˜¯ä¸€ä¸ª**æ•°æ®æ”¶é›†å™¨ + åˆ†æå™¨**ï¼Œå®ƒçš„è¾“å‡ºåº”è¯¥èƒ½å¤Ÿï¼š

1. ç›´æ¥é˜…è¯»ï¼ˆJSON æ ¼å¼ï¼‰
2. å¯è§†åŒ–å±•ç¤ºï¼ˆæä¾›ç»™å‰ç«¯ï¼‰
3. é›†æˆåˆ° CI/CDï¼ˆæ€§èƒ½é—¨ç¦ï¼‰

---

## æ ¸å¿ƒåŠŸèƒ½è®¾è®¡

### é˜¶æ®µä¸€ï¼šæœ€å°å¯ç”¨ç‰ˆæœ¬ï¼ˆMVPï¼‰

**ç›®æ ‡**ï¼šå®ç°ä¸€ä¸ªèƒ½ç”¨çš„ç‰ˆæœ¬ï¼Œè¾“å‡ºå¯è¯»çš„åˆ†ææŠ¥å‘Š

#### åŠŸèƒ½ 1.1ï¼šåŸºç¡€æ•°æ®æ”¶é›†

**è¦æ”¶é›†ä»€ä¹ˆï¼Ÿ**

```rust
// æ ¸å¿ƒæ•°æ®ç»“æ„
struct BundleReport {
  // å…ƒæ•°æ®
  timestamp: u64,
  rspack_version: String,

  // æ€»è§ˆ
  summary: Summary,

  // èµ„äº§ï¼ˆæœ€ç»ˆè¾“å‡ºçš„æ–‡ä»¶ï¼‰
  assets: Vec<Asset>,

  // æ¨¡å—ï¼ˆæºä»£ç æ–‡ä»¶ï¼‰
  modules: Vec<Module>,

  // ä»£ç å—
  chunks: Vec<Chunk>,
}

struct Summary {
  total_size: u64,        // æ€»å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  total_assets: usize,    // è¾“å‡ºæ–‡ä»¶æ•°é‡
  total_modules: usize,   // æ¨¡å—æ•°é‡
  total_chunks: usize,    // chunk æ•°é‡
  build_time: f64,        // æ„å»ºè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
}

struct Asset {
  name: String,           // æ–‡ä»¶åï¼Œå¦‚ "main.js"
  size: u64,              // æ–‡ä»¶å¤§å°
  chunks: Vec<String>,    // å…³è”çš„ chunk
  emitted: bool,          // æ˜¯å¦å®é™…è¾“å‡º
}

struct Module {
  id: String,             // æ¨¡å—å”¯ä¸€ ID
  name: String,           // å¯è¯»åç§°ï¼Œå¦‚ "./src/index.js"
  size: u64,              // æ¨¡å—å¤§å°
  chunks: Vec<String>,    // åŒ…å«æ­¤æ¨¡å—çš„ chunks
}

struct Chunk {
  id: String,             // chunk ID
  names: Vec<String>,     // chunk åç§°
  size: u64,              // chunk å¤§å°
  modules: Vec<String>,   // åŒ…å«çš„æ¨¡å— ID åˆ—è¡¨
  entry: bool,            // æ˜¯å¦å…¥å£ chunk
  initial: bool,          // æ˜¯å¦åˆå§‹ chunk
}
```

**å®ç°è¦ç‚¹**ï¼š

```rust
// åœ¨ after_emit hook ä¸­æ”¶é›†æ•°æ®
async fn after_emit(&self, compilation: &mut Compilation) -> Result<()> {
  let start = Instant::now();

  // 1. æ”¶é›† Assetsï¼ˆè¾“å‡ºæ–‡ä»¶ï¼‰
  let assets = collect_assets(compilation);

  // 2. æ”¶é›† Modulesï¼ˆæºæ–‡ä»¶ï¼‰
  let modules = collect_modules(compilation);

  // 3. æ”¶é›† Chunksï¼ˆä»£ç å—ï¼‰
  let chunks = collect_chunks(compilation);

  // 4. ç”Ÿæˆæ‘˜è¦
  let summary = Summary {
    total_size: assets.iter().map(|a| a.size).sum(),
    total_assets: assets.len(),
    total_modules: modules.len(),
    total_chunks: chunks.len(),
    build_time: start.elapsed().as_millis() as f64,
  };

  // 5. æ„å»ºæŠ¥å‘Š
  let report = BundleReport {
    timestamp: current_timestamp(),
    rspack_version: get_rspack_version(),
    summary,
    assets,
    modules,
    chunks,
  };

  // 6. è¾“å‡ºæŠ¥å‘Š
  output_report(&report, &self.options);

  Ok(())
}
```

**å…³é”®å®ç°**ï¼š

```rust
fn collect_assets(compilation: &Compilation) -> Vec<Asset> {
  compilation
    .assets()
    .iter()
    .map(|(name, asset)| {
      Asset {
        name: name.to_string(),
        size: asset.source.size() as u64,
        chunks: get_asset_chunks(name, compilation),
        emitted: true,
      }
    })
    .collect()
}

fn collect_modules(compilation: &Compilation) -> Vec<Module> {
  let module_graph = compilation.get_module_graph();
  let chunk_graph = &compilation.chunk_graph;

  module_graph
    .modules()
    .map(|(id, module)| {
      Module {
        id: id.to_string(),
        name: module.readable_identifier(&compilation.options.context).to_string(),
        size: get_module_size(module.as_ref()),
        chunks: get_module_chunks(id, chunk_graph),
      }
    })
    .collect()
}

fn collect_chunks(compilation: &Compilation) -> Vec<Chunk> {
  let chunk_graph = &compilation.chunk_graph;
  let module_graph = compilation.get_module_graph();

  compilation
    .chunk_by_ukey
    .iter()
    .map(|(ukey, chunk)| {
      let modules = chunk_graph
        .get_chunk_modules(ukey, &module_graph)
        .iter()
        .map(|m| m.identifier().to_string())
        .collect();

      Chunk {
        id: ukey.as_u32().to_string(),
        names: chunk.name().map(|n| vec![n.to_string()]).unwrap_or_default(),
        size: calculate_chunk_size(&modules, &module_graph),
        modules,
        entry: chunk.has_entry_module(chunk_graph),
        initial: chunk.can_be_initial(chunk_graph),
      }
    })
    .collect()
}

// è·å–æ¨¡å—çœŸå®å¤§å°
fn get_module_size(module: &dyn Module) -> u64 {
  module
    .original_source()
    .map(|s| s.size() as u64)
    .unwrap_or(0)
}
```

**è¾“å‡ºæ ¼å¼**ï¼š

```rust
fn output_report(report: &BundleReport, options: &PluginOptions) {
  // 1. è¾“å‡º JSON æ–‡ä»¶
  if let Some(path) = &options.report_filename {
    let json = serde_json::to_string_pretty(report).unwrap();
    std::fs::write(path, json).unwrap();
    println!("ğŸ“Š Bundle analysis saved to: {}", path);
  }

  // 2. è°ƒç”¨å›è°ƒ
  if let Some(callback) = &options.on_analyzed {
    callback(report.clone()).await;
  }
}
```

---

#### åŠŸèƒ½ 1.2ï¼šç®€å•çš„ç»ˆç«¯è¾“å‡º

**ç›®æ ‡**ï¼šæ„å»ºå®Œæˆåç›´æ¥åœ¨ç»ˆç«¯æ˜¾ç¤ºå…³é”®ä¿¡æ¯

```rust
fn print_summary(report: &BundleReport) {
  use byte_unit::{Byte, UnitType};

  println!("\nğŸ“¦ Bundle Analysis Summary");
  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

  let total = Byte::from_u64(report.summary.total_size);
  println!("Total Size:    {}", total.get_appropriate_unit(UnitType::Binary));
  println!("Assets:        {}", report.summary.total_assets);
  println!("Modules:       {}", report.summary.total_modules);
  println!("Chunks:        {}", report.summary.total_chunks);
  println!("Build Time:    {:.2}ms", report.summary.build_time);

  println!("\nğŸ“„ Largest Assets:");
  let mut assets = report.assets.clone();
  assets.sort_by_key(|a| std::cmp::Reverse(a.size));

  for asset in assets.iter().take(5) {
    let size = Byte::from_u64(asset.size);
    println!("  {} - {}", asset.name, size.get_appropriate_unit(UnitType::Binary));
  }

  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
}
```

---

### é˜¶æ®µäºŒï¼šæ·±åº¦åˆ†æ

**ç›®æ ‡**ï¼šæä¾›æ›´æœ‰ä»·å€¼çš„åˆ†ææ•°æ®

#### åŠŸèƒ½ 2.1ï¼šä¾èµ–åŒ…åˆ†æï¼ˆæœ€å®ç”¨ï¼ï¼‰

**ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ**

- node_modules é€šå¸¸å ç”¨ 70%+ çš„ä½“ç§¯
- å¼€å‘è€…éœ€è¦çŸ¥é“å“ªä¸ªåŒ…æœ€é‡ï¼Œè€ƒè™‘æ˜¯å¦æ›¿æ¢

**æ•°æ®ç»“æ„**ï¼š

```rust
struct PackageAnalysis {
  packages: Vec<PackageInfo>,
  total_size: u64,
  total_count: usize,
}

struct PackageInfo {
  name: String,              // åŒ…åï¼Œå¦‚ "react"
  version: String,           // ç‰ˆæœ¬ï¼Œå¦‚ "18.2.0"
  size: u64,                 // å ç”¨å¤§å°
  module_count: usize,       // åŒ…å«çš„æ¨¡å—æ•°
  modules: Vec<String>,      // æ¨¡å—è·¯å¾„åˆ—è¡¨
  main_fields: Vec<String>,  // å®é™…ä½¿ç”¨çš„å…¥å£
}
```

**å®ç°æ€è·¯**ï¼š

```rust
fn analyze_packages(modules: &[Module]) -> PackageAnalysis {
  let mut package_map: HashMap<String, Vec<&Module>> = HashMap::new();

  // 1. åˆ†ç»„ï¼šæŒ‰åŒ…åèšåˆæ¨¡å—
  for module in modules {
    if let Some((package_name, _)) = parse_package_path(&module.name) {
      package_map.entry(package_name).or_default().push(module);
    }
  }

  // 2. ç»Ÿè®¡æ¯ä¸ªåŒ…çš„ä¿¡æ¯
  let mut packages: Vec<PackageInfo> = package_map
    .into_iter()
    .map(|(name, mods)| {
      let version = resolve_package_version(&name);  // ä» package.json è¯»å–
      let size = mods.iter().map(|m| m.size).sum();

      PackageInfo {
        name: name.clone(),
        version,
        size,
        module_count: mods.len(),
        modules: mods.iter().map(|m| m.name.clone()).collect(),
        main_fields: vec![], // å¯é€‰
      }
    })
    .collect();

  // 3. æŒ‰å¤§å°æ’åº
  packages.sort_by_key(|p| std::cmp::Reverse(p.size));

  PackageAnalysis {
    total_size: packages.iter().map(|p| p.size).sum(),
    total_count: packages.len(),
    packages,
  }
}

// è§£æåŒ…è·¯å¾„
// "node_modules/react/index.js" -> ("react", "index.js")
// "node_modules/@babel/core/lib/index.js" -> ("@babel/core", "lib/index.js")
fn parse_package_path(path: &str) -> Option<(String, String)> {
  let parts: Vec<&str> = path.split("node_modules/").collect();
  if parts.len() < 2 {
    return None;
  }

  let after_nm = parts[1];
  let segments: Vec<&str> = after_nm.split('/').collect();

  let (pkg_name, rest) = if segments[0].starts_with('@') {
    // scoped package: @babel/core
    let name = format!("{}/{}", segments[0], segments.get(1)?);
    let rest = segments[2..].join("/");
    (name, rest)
  } else {
    // normal package: react
    let name = segments[0].to_string();
    let rest = segments[1..].join("/");
    (name, rest)
  };

  Some((pkg_name, rest))
}

// è¯»å– package.json è·å–ç‰ˆæœ¬
fn resolve_package_version(package_name: &str) -> String {
  // 1. ä»é¡¹ç›®æ ¹ç›®å½•å¼€å§‹æŸ¥æ‰¾
  // 2. è¯»å– node_modules/{package_name}/package.json
  // 3. è§£æ version å­—æ®µ

  // ç®€åŒ–å®ç°
  "unknown".to_string()
}
```

**ç»ˆç«¯è¾“å‡º**ï¼š

```rust
fn print_package_analysis(analysis: &PackageAnalysis) {
  use byte_unit::{Byte, UnitType};

  println!("\nğŸ“¦ Top 10 Packages by Size:");
  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

  for (i, pkg) in analysis.packages.iter().take(10).enumerate() {
    let size = Byte::from_u64(pkg.size);
    let percentage = (pkg.size as f64 / analysis.total_size as f64) * 100.0;

    println!(
      "{:2}. {:30} {:>10} ({:>5.1}%) - {} modules",
      i + 1,
      format!("{}@{}", pkg.name, pkg.version),
      size.get_appropriate_unit(UnitType::Binary).to_string(),
      percentage,
      pkg.module_count
    );
  }

  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
}
```

---

#### åŠŸèƒ½ 2.2ï¼šé‡å¤æ¨¡å—æ£€æµ‹

**ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ**

- åŒä¸€ä¸ªæ¨¡å—è¢«å¤šä¸ª chunk åŒ…å« = æµªè´¹ç©ºé—´
- åº”è¯¥æŠ½å–åˆ°å…¬å…± chunk

**æ•°æ®ç»“æ„**ï¼š

```rust
struct DuplicateAnalysis {
  duplicates: Vec<DuplicateModule>,
  wasted_size: u64,  // æµªè´¹çš„æ€»å¤§å°
}

struct DuplicateModule {
  module_id: String,
  module_name: String,
  size: u64,
  occurrences: usize,     // å‡ºç°æ¬¡æ•°
  chunks: Vec<String>,    // åŒ…å«å®ƒçš„ chunks
  wasted_size: u64,       // æµªè´¹çš„å¤§å° = size * (occurrences - 1)
}
```

**å®ç°**ï¼š

```rust
fn detect_duplicates(modules: &[Module], chunks: &[Chunk]) -> DuplicateAnalysis {
  // 1. ç»Ÿè®¡æ¯ä¸ªæ¨¡å—å‡ºç°åœ¨å¤šå°‘ä¸ª chunk ä¸­
  let mut module_chunks: HashMap<String, Vec<String>> = HashMap::new();

  for chunk in chunks {
    for module_id in &chunk.modules {
      module_chunks
        .entry(module_id.clone())
        .or_default()
        .push(chunk.id.clone());
    }
  }

  // 2. æ‰¾å‡ºé‡å¤çš„æ¨¡å—ï¼ˆå‡ºç°åœ¨ 2+ chunksï¼‰
  let duplicates: Vec<DuplicateModule> = module_chunks
    .into_iter()
    .filter(|(_, chunks)| chunks.len() > 1)
    .filter_map(|(module_id, chunks)| {
      let module = modules.iter().find(|m| m.id == module_id)?;
      let occurrences = chunks.len();
      let wasted = module.size * (occurrences as u64 - 1);

      Some(DuplicateModule {
        module_id: module_id.clone(),
        module_name: module.name.clone(),
        size: module.size,
        occurrences,
        chunks,
        wasted_size: wasted,
      })
    })
    .collect();

  let wasted_size = duplicates.iter().map(|d| d.wasted_size).sum();

  DuplicateAnalysis {
    duplicates,
    wasted_size,
  }
}
```

**ç»ˆç«¯è¾“å‡º**ï¼š

```rust
fn print_duplicate_analysis(analysis: &DuplicateAnalysis) {
  if analysis.duplicates.is_empty() {
    println!("âœ… No duplicate modules found!");
    return;
  }

  use byte_unit::{Byte, UnitType};

  println!("\nâš ï¸  Duplicate Modules Detected:");
  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  println!(
    "Total wasted: {}",
    Byte::from_u64(analysis.wasted_size).get_appropriate_unit(UnitType::Binary)
  );

  let mut sorted = analysis.duplicates.clone();
  sorted.sort_by_key(|d| std::cmp::Reverse(d.wasted_size));

  for dup in sorted.iter().take(10) {
    let size = Byte::from_u64(dup.size);
    let wasted = Byte::from_u64(dup.wasted_size);

    println!(
      "\n  {} ({} -> wasted: {})",
      dup.module_name,
      size.get_appropriate_unit(UnitType::Binary),
      wasted.get_appropriate_unit(UnitType::Binary)
    );
    println!("  Appears in {} chunks: {:?}", dup.occurrences, dup.chunks);
  }

  println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
}
```

---

### é˜¶æ®µä¸‰ï¼šå¯è§†åŒ–æ”¯æŒ

**ç›®æ ‡**ï¼šç”Ÿæˆå‰ç«¯å¯ç›´æ¥ä½¿ç”¨çš„æ•°æ®æ ¼å¼

#### åŠŸèƒ½ 3.1ï¼šæ ‘çŠ¶å›¾æ•°æ®ï¼ˆTreemapï¼‰

**ç”¨é€”**ï¼šç”¨äº echarts/d3.js ç»˜åˆ¶æ ‘çŠ¶å›¾

```rust
struct TreemapData {
  name: String,
  value: u64,              // å¤§å°
  children: Vec<TreemapData>,
  path: Option<String>,    // å®Œæ•´è·¯å¾„
  item_style: Option<ItemStyle>,
}

struct ItemStyle {
  color: String,  // æ ¹æ®ç±»å‹ç€è‰²
}

fn generate_treemap(modules: &[Module]) -> TreemapData {
  let mut root = TreemapNode::new("root");

  // æŒ‰è·¯å¾„æ„å»ºæ ‘
  for module in modules {
    insert_module_into_tree(&mut root, module);
  }

  build_treemap_data(root)
}

struct TreemapNode {
  name: String,
  size: u64,
  children: HashMap<String, TreemapNode>,
  is_leaf: bool,
  module_type: Option<String>,
}

fn insert_module_into_tree(root: &mut TreemapNode, module: &Module) {
  let path = &module.name;
  let segments: Vec<&str> = path.split('/').filter(|s| !s.is_empty()).collect();

  let mut current = root;

  for (i, segment) in segments.iter().enumerate() {
    let is_last = i == segments.len() - 1;

    current.size += module.size;

    if is_last {
      // å¶å­èŠ‚ç‚¹
      let mut leaf = TreemapNode::new(segment);
      leaf.size = module.size;
      leaf.is_leaf = true;
      leaf.module_type = Some(detect_module_type(path));
      current.children.insert(segment.to_string(), leaf);
    } else {
      // ä¸­é—´èŠ‚ç‚¹
      current = current
        .children
        .entry(segment.to_string())
        .or_insert_with(|| TreemapNode::new(segment));
    }
  }
}

fn build_treemap_data(node: TreemapNode) -> TreemapData {
  let children: Vec<TreemapData> = node
    .children
    .into_iter()
    .map(|(_, child)| build_treemap_data(child))
    .collect();

  let color = if let Some(ref module_type) = node.module_type {
    get_color_for_type(module_type)
  } else {
    "#cccccc".to_string()
  };

  TreemapData {
    name: node.name,
    value: node.size,
    children,
    path: None,
    item_style: Some(ItemStyle { color }),
  }
}

fn get_color_for_type(module_type: &str) -> String {
  match module_type {
    "javascript" => "#f7df1e".to_string(),
    "typescript" => "#3178c6".to_string(),
    "css" => "#264de4".to_string(),
    "image" => "#4caf50".to_string(),
    "json" => "#000000".to_string(),
    _ => "#999999".to_string(),
  }
}

fn detect_module_type(path: &str) -> String {
  if path.ends_with(".ts") || path.ends_with(".tsx") {
    "typescript"
  } else if path.ends_with(".js") || path.ends_with(".jsx") {
    "javascript"
  } else if path.ends_with(".css") || path.ends_with(".scss") {
    "css"
  } else if path.ends_with(".png") || path.ends_with(".jpg") || path.ends_with(".svg") {
    "image"
  } else if path.ends_with(".json") {
    "json"
  } else {
    "other"
  }.to_string()
}
```

---

### é˜¶æ®µå››ï¼šé…ç½®ä¸è¾“å‡º

**ç›®æ ‡**ï¼šçµæ´»çš„é…ç½®é€‰é¡¹

```rust
pub struct BundleAnalyzerPluginOpts {
  // è¾“å‡ºé€‰é¡¹
  pub report_filename: Option<String>,  // JSON æŠ¥å‘Šè·¯å¾„
  pub open_analyzer: bool,              // æ˜¯å¦è‡ªåŠ¨æ‰“å¼€å¯è§†åŒ–é¡µé¢

  // åˆ†æé€‰é¡¹
  pub analyze_mode: AnalyzeMode,
  pub exclude_assets: Option<Vec<String>>,  // æ’é™¤çš„èµ„æºï¼ˆglobï¼‰
  pub stats_options: StatsOptions,

  // å›è°ƒ
  pub on_analyzed: Option<CompilationHookFn>,
}

pub enum AnalyzeMode {
  Full,      // å®Œæ•´åˆ†æï¼ˆåŒ…å«æ‰€æœ‰åŠŸèƒ½ï¼‰
  Static,    // åªç”Ÿæˆé™æ€æŠ¥å‘Š
  Disabled,  // ç¦ç”¨
}

pub struct StatsOptions {
  pub show_packages: bool,      // æ˜¯å¦åˆ†æ packages
  pub show_duplicates: bool,    // æ˜¯å¦æ£€æµ‹é‡å¤
  pub top_modules_count: usize, // æ˜¾ç¤º top N æ¨¡å—
}

impl Default for BundleAnalyzerPluginOpts {
  fn default() -> Self {
    Self {
      report_filename: Some("bundle-report.json".to_string()),
      open_analyzer: false,
      analyze_mode: AnalyzeMode::Full,
      exclude_assets: None,
      stats_options: StatsOptions {
        show_packages: true,
        show_duplicates: true,
        top_modules_count: 20,
      },
      on_analyzed: None,
    }
  }
}
```

---

## æœ€ç»ˆçš„æ•°æ®ç»“æ„

```rust
// æœ€ç»ˆè¾“å‡ºçš„å®Œæ•´æŠ¥å‘Š
#[derive(Serialize, Deserialize)]
pub struct BundleReport {
  // åŸºç¡€ä¿¡æ¯
  pub timestamp: u64,
  pub rspack_version: String,
  pub summary: Summary,

  // æ ¸å¿ƒæ•°æ®
  pub assets: Vec<Asset>,
  pub modules: Vec<Module>,
  pub chunks: Vec<Chunk>,

  // åˆ†æç»“æœ
  pub package_analysis: Option<PackageAnalysis>,
  pub duplicate_analysis: Option<DuplicateAnalysis>,

  // å¯è§†åŒ–æ•°æ®
  pub treemap_data: Option<TreemapData>,
}
```

---

## å®æ–½è®¡åˆ’

### ç¬¬ä¸€æ­¥ï¼šå®ç° MVPï¼ˆé˜¶æ®µä¸€ï¼‰

- [ ] å®šä¹‰åŸºç¡€æ•°æ®ç»“æ„ï¼ˆAssetã€Moduleã€Chunkã€Summaryï¼‰
- [ ] å®ç° `collect_assets()`
- [ ] å®ç° `collect_modules()`ï¼ˆå‡†ç¡®çš„å¤§å°è®¡ç®—ï¼‰
- [ ] å®ç° `collect_chunks()`
- [ ] å®ç° JSON è¾“å‡º
- [ ] å®ç°ç®€å•çš„ç»ˆç«¯æ‘˜è¦è¾“å‡º

**éªŒæ”¶æ ‡å‡†**ï¼š

- èƒ½è¾“å‡º bundle-report.json
- ç»ˆç«¯æ˜¾ç¤ºæ€»å¤§å°ã€æ–‡ä»¶æ•°ç­‰åŸºç¡€ä¿¡æ¯
- æ•°æ®å‡†ç¡®ï¼ˆå’Œå®é™…æ–‡ä»¶å¤§å°ä¸€è‡´ï¼‰

---

### ç¬¬äºŒæ­¥ï¼šæ·»åŠ æ·±åº¦åˆ†æï¼ˆé˜¶æ®µäºŒï¼‰

- [ ] å®ç°åŒ…åˆ†æï¼ˆ`analyze_packages()`ï¼‰
- [ ] å®ç° `parse_package_path()`
- [ ] å®ç° `resolve_package_version()`ï¼ˆè¯»å– package.jsonï¼‰
- [ ] å®ç°é‡å¤æ£€æµ‹ï¼ˆ`detect_duplicates()`ï¼‰
- [ ] ç¾åŒ–ç»ˆç«¯è¾“å‡º

**éªŒæ”¶æ ‡å‡†**ï¼š

- ç»ˆç«¯æ˜¾ç¤º Top 10 æœ€å¤§çš„åŒ…
- æ˜¾ç¤ºé‡å¤æ¨¡å—åŠæµªè´¹çš„ç©ºé—´
- æ•°æ®å¯è¯»æ€§å¥½

---

### ç¬¬ä¸‰æ­¥ï¼šå¯è§†åŒ–æ•°æ®ï¼ˆé˜¶æ®µä¸‰ï¼‰

- [ ] å®ç°æ ‘çŠ¶å›¾æ•°æ®ç”Ÿæˆ
- [ ] æ”¯æŒæŒ‰ç±»å‹ç€è‰²
- [ ] ï¼ˆå¯é€‰ï¼‰ç”Ÿæˆ HTML å¯è§†åŒ–é¡µé¢

**éªŒæ”¶æ ‡å‡†**ï¼š

- JSON ä¸­åŒ…å« treemap_data
- æ•°æ®å¯ä»¥ç›´æ¥ç”¨äº echarts

---

### ç¬¬å››æ­¥ï¼šå®Œå–„é…ç½®ï¼ˆé˜¶æ®µå››ï¼‰

- [ ] å®ç°é…ç½®é€‰é¡¹
- [ ] æ”¯æŒæ’é™¤æŸäº›èµ„æº
- [ ] æ”¯æŒä¸åŒçš„åˆ†ææ¨¡å¼

**éªŒæ”¶æ ‡å‡†**ï¼š

- é…ç½®çµæ´»å¯ç”¨
- æ–‡æ¡£å®Œå–„

---

## å…³é”®ä»£ç ç‰‡æ®µ

### å‡†ç¡®è·å–æ¨¡å—å¤§å°

```rust
fn get_module_size(module: &dyn Module) -> u64 {
  // æ–¹æ³•1ï¼šä»åŸå§‹æºè·å–
  if let Some(source) = module.original_source() {
    return source.size() as u64;
  }

  // æ–¹æ³•2ï¼šä»æ„å»ºä¿¡æ¯è·å–
  if let Some(build_meta) = module.build_meta() {
    // å°è¯•ä» build_meta è·å–å¤§å°
  }

  // å…œåº•ï¼šè¿”å› 0
  0
}
```

### è·å– Asset å…³è”çš„ Chunks

```rust
fn get_asset_chunks(asset_name: &str, compilation: &Compilation) -> Vec<String> {
  compilation
    .chunk_by_ukey
    .values()
    .filter(|chunk| {
      chunk.files().contains(&asset_name.into())
    })
    .map(|chunk| chunk.id().to_string())
    .collect()
}
```

### è·å– Module æ‰€åœ¨çš„ Chunks

```rust
fn get_module_chunks(module_id: &ModuleIdentifier, chunk_graph: &ChunkGraph) -> Vec<String> {
  chunk_graph
    .get_module_chunks(*module_id)
    .iter()
    .map(|chunk_ukey| chunk_ukey.as_u32().to_string())
    .collect()
}
```

---

## æ€»ç»“

è¿™ä¸ªè®¾è®¡çš„æ ¸å¿ƒæ€è·¯ï¼š

1. **ä»ç®€å•å¼€å§‹**ï¼šå…ˆå®ç° MVPï¼Œä¿è¯æ•°æ®å‡†ç¡®
2. **é€æ­¥å¢å¼º**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½å¢åŠ ä¸€ä¸ªå®ç”¨åŠŸèƒ½
3. **æ³¨é‡å®ç”¨æ€§**ï¼šåŒ…åˆ†æã€é‡å¤æ£€æµ‹éƒ½æ˜¯çœŸæ­£æœ‰ç”¨çš„
4. **å¯è§†åŒ–å‹å¥½**ï¼šè¾“å‡ºçš„æ•°æ®å¯ä»¥ç›´æ¥ç”¨äºå‰ç«¯å±•ç¤º

å»ºè®®æŒ‰ç…§**ç¬¬ä¸€æ­¥ â†’ ç¬¬äºŒæ­¥ â†’ ç¬¬ä¸‰æ­¥ â†’ ç¬¬å››æ­¥**çš„é¡ºåºå®æ–½ï¼Œæ¯å®Œæˆä¸€æ­¥å°±æœ‰ä¸€ä¸ªå¯ç”¨çš„ç‰ˆæœ¬ã€‚
