# Rspack 插件生态系统 API 文档

## 插件架构概述

Rspack 拥有一个丰富的插件生态系统，共包含 **41个插件 crate**，这些插件遵循统一的架构模式，为现代前端构建提供了完整的功能支持。

### 统一的插件接口

所有插件都实现了核心的 `Plugin` trait：

```rust
/// 插件核心 trait
pub trait Plugin: Debug + Send + Sync {
    /// 插件名称
    fn name(&self) -> &'static str;
    
    /// 应用插件到编译器
    fn apply(&self, ctx: &mut ApplyContext<'_>) -> Result<()>;
    
    /// 插件执行阶段（用于排序）
    fn stage(&self) -> i32 {
        0
    }
}

/// 插件应用上下文
pub struct ApplyContext<'a> {
    pub context: &'a Context,
    pub compiler_options: &'a CompilerOptions,
    pub compiler_hooks: &'a mut CompilerHooks,
    pub compilation_hooks: &'a mut CompilationHooks,
    pub normal_module_factory_hooks: &'a mut NormalModuleFactoryHooks,
    pub context_module_factory_hooks: &'a mut ContextModuleFactoryHooks,
    pub resolver_factory: &'a ResolverFactory,
    // 更多钩子...
}
```

## 核心构建插件

### rspack_plugin_asset - 资源处理插件

处理各种静态资源文件（图片、字体、文档等）。

```rust
/// 资源插件配置
#[derive(Debug, Clone)]
pub struct AssetPluginOptions {
    /// 内联阈值（字节）
    pub inline_limit: Option<u32>,
    /// 输出路径
    pub output_path: Option<String>,
    /// 文件名模板
    pub filename: Option<String>,
    /// 公共路径
    pub public_path: Option<String>,
}

/// 资源插件
#[derive(Debug)]
pub struct AssetPlugin {
    options: AssetPluginOptions,
}

impl AssetPlugin {
    /// 创建资源插件
    pub fn new(options: AssetPluginOptions) -> Self {
        Self { options }
    }
    
    /// 使用默认配置创建
    pub fn default() -> Self {
        Self::new(AssetPluginOptions::default())
    }
}

impl Plugin for AssetPlugin {
    fn name(&self) -> &'static str {
        "AssetPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 注册资源解析器和生成器
        ctx.normal_module_factory_hooks.parser.tap(
            asset_parser_hook::new()
        );
        ctx.normal_module_factory_hooks.generator.tap(
            asset_generator_hook::new(&self.options)
        );
        Ok(())
    }
}

/// 资源解析器和生成器
pub struct AssetParserAndGenerator {
    options: AssetGeneratorOptions,
}

impl ParserAndGenerator for AssetParserAndGenerator {
    fn source_types(&self) -> &[SourceType] {
        &[SourceType::Asset]
    }
    
    fn parse(&mut self, parse_context: ParseContext) -> Result<ParseResult> {
        // 解析资源文件
        let source = parse_context.source;
        let size = source.size();
        
        Ok(ParseResult {
            dependencies: vec![],
            source: Some(source),
            side_effects: false,
        })
    }
    
    fn generate(
        &self,
        source: &dyn Source,
        module: &BoxModule,
        generate_context: &mut GenerateContext,
    ) -> Result<GenerateResult> {
        let content = source.source();
        let should_inline = content.len() <= self.options.inline_limit;
        
        if should_inline {
            // 生成 Data URL
            let data_url = format!("data:{};base64,{}", 
                detect_mime_type(&content),
                base64::encode(&content)
            );
            Ok(GenerateResult {
                inner: GenerateResultInner::Source(
                    RawSource::from(format!("module.exports = {}", 
                        serde_json::to_string(&data_url)?
                    )).boxed()
                ),
                ..Default::default()
            })
        } else {
            // 生成文件引用
            let filename = self.generate_filename(module)?;
            generate_context.emit_asset(filename.clone(), source.clone());
            
            Ok(GenerateResult {
                inner: GenerateResultInner::Source(
                    RawSource::from(format!("module.exports = __webpack_public_path__ + {};", 
                        serde_json::to_string(&filename)?
                    )).boxed()
                ),
                ..Default::default()
            })
        }
    }
}
```

### rspack_plugin_entry - 入口管理插件

管理应用程序的入口点和依赖关系。

```rust
/// 入口插件
#[derive(Debug)]
pub struct EntryPlugin {
    /// 上下文路径
    context: Context,
    /// 入口请求
    entry: String,
    /// 入口选项
    options: EntryOptions,
}

impl EntryPlugin {
    /// 创建入口插件
    pub fn new(context: Context, entry: String, options: EntryOptions) -> Self {
        Self { context, entry, options }
    }
}

impl Plugin for EntryPlugin {
    fn name(&self) -> &'static str {
        "EntryPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compiler_hooks.compilation.tap(
            compilation_hook::new(self)
        );
        Ok(())
    }
}

/// 入口依赖
#[derive(Debug, Clone)]
pub struct EntryDependency {
    request: String,
    context: Context,
    options: EntryOptions,
}

impl Dependency for EntryDependency {
    fn id(&self) -> &DependencyId {
        &self.id
    }
    
    fn dependency_type(&self) -> &DependencyType {
        &DependencyType::Entry
    }
    
    fn category(&self) -> &DependencyCategory {
        &DependencyCategory::Esm
    }
    
    fn resource_identifier(&self) -> Option<&str> {
        Some(&self.request)
    }
}
```

### rspack_plugin_javascript - JavaScript 核心插件

提供 JavaScript/TypeScript 语言支持的核心功能，是最复杂的插件（144个文件）。

```rust
/// JavaScript 插件
#[derive(Debug)]
pub struct JavaScriptModulesPlugin;

impl Plugin for JavaScriptModulesPlugin {
    fn name(&self) -> &'static str {
        "JavaScriptModulesPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 注册 JavaScript 解析器和生成器
        ctx.normal_module_factory_hooks
            .create_parser
            .tap(create_js_parser_hook::new());
            
        ctx.normal_module_factory_hooks
            .create_generator
            .tap(create_js_generator_hook::new());
            
        // 注册编译钩子
        ctx.compilation_hooks
            .render_manifest
            .tap(render_manifest_hook::new());
            
        Ok(())
    }
}

/// JavaScript 解析器
pub struct JavaScriptParser {
    options: JavaScriptParserOptions,
    dependencies: Vec<BoxDependency>,
    source_map: Option<SourceMap>,
}

impl JavaScriptParser {
    pub fn new(options: JavaScriptParserOptions) -> Self {
        Self {
            options,
            dependencies: Vec::new(),
            source_map: None,
        }
    }
    
    /// 解析 ES 模块导入
    fn parse_import(&mut self, import: &ImportDecl) -> Result<()> {
        let dep = EsmImportDependency::new(
            import.src.value.to_string(),
            import.span.into(),
            self.get_import_specifiers(import),
        );
        self.dependencies.push(Box::new(dep));
        Ok(())
    }
    
    /// 解析动态导入
    fn parse_dynamic_import(&mut self, call: &CallExpr) -> Result<()> {
        if let Some(arg) = call.args.first() {
            let dep = DynamicImportDependency::new(
                self.evaluate_expression(&arg.expr)?,
                call.span.into(),
            );
            self.dependencies.push(Box::new(dep));
        }
        Ok(())
    }
    
    /// 解析 CommonJS require
    fn parse_require(&mut self, call: &CallExpr) -> Result<()> {
        if let Some(arg) = call.args.first() {
            let dep = CommonJsRequireDependency::new(
                self.evaluate_expression(&arg.expr)?,
                call.span.into(),
            );
            self.dependencies.push(Box::new(dep));
        }
        Ok(())
    }
}

/// JavaScript 生成器
pub struct JavaScriptGenerator {
    options: JavaScriptGeneratorOptions,
}

impl JavaScriptGenerator {
    /// 生成模块代码
    fn generate_module(
        &self,
        module: &BoxModule,
        compilation: &Compilation,
        runtime: Option<&RuntimeSpec>,
    ) -> Result<GenerateResult> {
        let mut source = ConcatSource::new();
        
        // 生成模块包装器
        source.add(RawSource::from("(function(module, exports, __webpack_require__) {\n"));
        
        // 添加模块源码
        if let Some(module_source) = module.source() {
            source.add(module_source.clone());
        }
        
        // 生成依赖注入代码
        for dep in module.get_dependencies() {
            if let Some(template) = dep.as_dependency_template() {
                template.apply(&mut source, compilation, runtime)?;
            }
        }
        
        source.add(RawSource::from("\n})"));
        
        Ok(GenerateResult {
            inner: GenerateResultInner::Source(source.boxed()),
            runtime_requirements: self.get_runtime_requirements(module),
        })
    }
}
```

## 样式处理插件

### rspack_plugin_css - CSS 处理插件

```rust
/// CSS 插件
#[derive(Debug)]
pub struct CssPlugin {
    options: CssPluginOptions,
}

#[derive(Debug, Clone)]
pub struct CssPluginOptions {
    /// 是否启用 CSS 模块
    pub modules: bool,
    /// 本地标识符名称模板
    pub local_ident_name: Option<String>,
    /// 导出本地标识符
    pub export_locals_convention: ExportLocalsConvention,
}

impl Plugin for CssPlugin {
    fn name(&self) -> &'static str {
        "CssPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.normal_module_factory_hooks
            .create_parser
            .tap(create_css_parser_hook::new(&self.options));
            
        ctx.normal_module_factory_hooks
            .create_generator
            .tap(create_css_generator_hook::new(&self.options));
            
        Ok(())
    }
}

/// CSS 解析器和生成器
pub struct CssParserAndGenerator {
    options: CssPluginOptions,
}

impl ParserAndGenerator for CssParserAndGenerator {
    fn source_types(&self) -> &[SourceType] {
        &[SourceType::Css]
    }
    
    fn parse(&mut self, parse_context: ParseContext) -> Result<ParseResult> {
        let source = parse_context.source.source();
        let stylesheet = parse_css(&source)?;
        
        let mut dependencies = Vec::new();
        
        // 解析 @import 规则
        for rule in &stylesheet.rules {
            if let CssRule::Import(import) = rule {
                let dep = CssImportDependency::new(
                    import.url.clone(),
                    import.media.clone(),
                );
                dependencies.push(Box::new(dep) as BoxDependency);
            }
        }
        
        // 处理 CSS 模块
        let processed_source = if self.options.modules {
            self.process_css_modules(&source, &stylesheet)?
        } else {
            source
        };
        
        Ok(ParseResult {
            dependencies,
            source: Some(RawSource::from(processed_source).boxed()),
            side_effects: false,
        })
    }
}
```

### rspack_plugin_extract_css - CSS 提取插件

```rust
/// CSS 提取插件
#[derive(Debug)]
pub struct ExtractCssPlugin {
    options: ExtractCssOptions,
}

#[derive(Debug, Clone)]
pub struct ExtractCssOptions {
    /// 输出文件名
    pub filename: String,
    /// chunk 文件名
    pub chunk_filename: Option<String>,
    /// 忽略顺序警告
    pub ignore_order: bool,
}

impl Plugin for ExtractCssPlugin {
    fn name(&self) -> &'static str {
        "ExtractCssPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 替换 CSS 依赖为提取依赖
        ctx.normal_module_factory_hooks
            .create_parser
            .tap(extract_css_parser_hook::new());
            
        // 在渲染阶段提取 CSS
        ctx.compilation_hooks
            .render_manifest
            .tap(extract_css_render_hook::new(&self.options));
            
        Ok(())
    }
}

/// CSS 提取依赖
#[derive(Debug, Clone)]
pub struct CssExtractDependency {
    identifier: String,
    content: String,
    media: Option<String>,
    source_map: Option<String>,
}

impl Dependency for CssExtractDependency {
    fn dependency_type(&self) -> &DependencyType {
        &DependencyType::CssExtract
    }
    
    fn category(&self) -> &DependencyCategory {
        &DependencyCategory::Css
    }
}
```

## 开发和调试插件

### rspack_plugin_devtool - 开发工具插件

```rust
/// Source Map 开发工具插件
#[derive(Debug)]
pub struct SourceMapDevToolPlugin {
    options: SourceMapDevToolOptions,
}

#[derive(Debug, Clone)]
pub struct SourceMapDevToolOptions {
    /// Source map 文件名模板
    pub filename: Option<String>,
    /// 是否添加到包中
    pub append: bool,
    /// 模块文件名模板
    pub module_filename_template: String,
    /// 回退模块文件名模板
    pub fallback_module_filename_template: String,
    /// 包含的文件模式
    pub include: Option<Vec<String>>,
    /// 排除的文件模式
    pub exclude: Option<Vec<String>>,
    /// Source map 选项
    pub source_map_options: SourceMapOptions,
}

impl Plugin for SourceMapDevToolPlugin {
    fn name(&self) -> &'static str {
        "SourceMapDevToolPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compilation_hooks
            .process_assets
            .tap(process_assets_hook::new(&self.options));
        Ok(())
    }
}

/// 生成 Source Map
fn generate_source_map(
    asset: &CompilationAsset,
    options: &SourceMapDevToolOptions
) -> Result<SourceMap> {
    let source = asset.source.source();
    let mut source_map = SourceMapBuilder::new(None);
    
    // 分析源码并生成映射
    let lines: Vec<&str> = source.lines().collect();
    for (line_index, line) in lines.iter().enumerate() {
        source_map.add_mapping(
            line_index as u32,
            0,
            Some(line_index as u32),
            Some(0),
            None,
        );
    }
    
    Ok(source_map.into_sourcemap())
}
```

### rspack_plugin_hmr - 热模块替换插件

```rust
/// 热模块替换插件
#[derive(Debug)]
pub struct HotModuleReplacementPlugin {
    options: HmrOptions,
}

#[derive(Debug, Clone)]
pub struct HmrOptions {
    /// 多步骤更新
    pub multi_step: bool,
    /// 完整哈希更新
    pub full_build_timeout: u32,
    /// 请求超时
    pub request_timeout: u32,
}

impl Plugin for HotModuleReplacementPlugin {
    fn name(&self) -> &'static str {
        "HotModuleReplacementPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 注入 HMR 运行时
        ctx.compilation_hooks
            .additional_tree_runtime_requirements
            .tap(hmr_runtime_hook::new());
            
        // 处理模块更新
        ctx.compilation_hooks
            .record
            .tap(hmr_record_hook::new());
            
        Ok(())
    }
}

/// HMR 运行时模块
#[derive(Debug)]
pub struct HotModuleReplacementRuntimeModule;

impl RuntimeModule for HotModuleReplacementRuntimeModule {
    fn name(&self) -> Identifier {
        "__webpack_require__.hmr".into()
    }
    
    fn generate(&self, compilation: &Compilation) -> Result<BoxSource> {
        let runtime_code = include_str!("./runtime/hmr.js");
        Ok(RawSource::from(runtime_code).boxed())
    }
}
```

## 优化插件

### rspack_plugin_split_chunks - 代码分割插件

```rust
/// 代码分割插件
#[derive(Debug)]
pub struct SplitChunksPlugin {
    options: SplitChunksOptions,
}

#[derive(Debug, Clone)]
pub struct SplitChunksOptions {
    /// 缓存组配置
    pub cache_groups: HashMap<String, CacheGroup>,
    /// 分割策略
    pub chunks: ChunksFilter,
    /// 最小 chunk 大小
    pub min_size: u32,
    /// 最大 chunk 大小
    pub max_size: u32,
    /// 最小共享次数
    pub min_chunks: u32,
    /// 最大异步请求数
    pub max_async_requests: u32,
    /// 最大初始请求数
    pub max_initial_requests: u32,
}

#[derive(Debug, Clone)]
pub struct CacheGroup {
    /// 测试条件
    pub test: Option<CacheGroupTest>,
    /// 优先级
    pub priority: i32,
    /// 是否重用现有 chunk
    pub reuse_existing_chunk: bool,
    /// 强制分割
    pub enforce: bool,
    /// 文件名
    pub name: Option<String>,
}

impl Plugin for SplitChunksPlugin {
    fn name(&self) -> &'static str {
        "SplitChunksPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compilation_hooks
            .optimize_chunks
            .tap(optimize_chunks_hook::new(&self.options));
        Ok(())
    }
}

/// 代码分割算法
impl SplitChunksPlugin {
    /// 执行代码分割
    fn split_chunks(
        &self,
        compilation: &mut Compilation,
        chunks: &[ChunkUkey],
    ) -> Result<()> {
        let module_graph = &compilation.module_graph;
        let chunk_graph = &mut compilation.chunk_graph;
        
        // 分析模块共享情况
        let module_usage = self.analyze_module_usage(module_graph, chunk_graph)?;
        
        // 创建候选分割
        let split_candidates = self.create_split_candidates(&module_usage)?;
        
        // 应用缓存组规则
        let final_splits = self.apply_cache_groups(&split_candidates)?;
        
        // 执行分割
        for split in final_splits {
            self.create_split_chunk(compilation, split)?;
        }
        
        Ok(())
    }
    
    /// 分析模块使用情况
    fn analyze_module_usage(
        &self,
        module_graph: &ModuleGraph,
        chunk_graph: &ChunkGraph,
    ) -> Result<ModuleUsageMap> {
        let mut usage_map = ModuleUsageMap::new();
        
        for module in module_graph.modules() {
            let chunks = chunk_graph.get_module_chunks(module.identifier());
            let usage = ModuleUsage {
                module: module.identifier(),
                chunks: chunks.clone(),
                size: module.size(&SourceType::JavaScript),
                reasons: module_graph.get_incoming_connections(module.identifier()),
            };
            usage_map.insert(module.identifier(), usage);
        }
        
        Ok(usage_map)
    }
}
```

### rspack_plugin_real_content_hash - 内容哈希插件

```rust
/// 真实内容哈希插件
#[derive(Debug)]
pub struct RealContentHashPlugin;

impl Plugin for RealContentHashPlugin {
    fn name(&self) -> &'static str {
        "RealContentHashPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compilation_hooks
            .process_assets
            .tap(content_hash_hook::new());
        Ok(())
    }
}

/// 计算真实内容哈希
fn compute_real_content_hash(
    compilation: &mut Compilation,
) -> Result<()> {
    let mut hash_updates = HashMap::new();
    
    // 遍历所有资源
    for (name, asset) in &compilation.assets {
        let content = asset.source.source();
        let hash = compute_hash(&content);
        
        // 检查文件名是否包含哈希占位符
        if name.contains("[contenthash]") {
            let new_name = name.replace("[contenthash]", &hash);
            hash_updates.insert(name.clone(), (new_name, hash));
        }
    }
    
    // 应用哈希更新
    for (old_name, (new_name, hash)) in hash_updates {
        if let Some(asset) = compilation.assets.remove(&old_name) {
            compilation.assets.insert(new_name.clone(), asset);
            
            // 更新 chunk 文件名
            for chunk in compilation.chunk_by_ukey.values_mut() {
                chunk.files.retain(|file| file != &old_name);
                chunk.files.insert(new_name.clone());
            }
        }
    }
    
    Ok(())
}
```

## 运行时插件

### rspack_plugin_runtime - 运行时核心插件

```rust
/// 运行时插件
#[derive(Debug)]
pub struct RuntimePlugin;

impl Plugin for RuntimePlugin {
    fn name(&self) -> &'static str {
        "RuntimePlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 注册各种运行时模块
        ctx.compilation_hooks
            .additional_tree_runtime_requirements
            .tap(runtime_requirements_hook::new());
            
        ctx.compilation_hooks
            .runtime_requirement_in_tree
            .tap(runtime_requirement_in_tree_hook::new());
            
        Ok(())
    }
}

/// JSONP Chunk 加载插件
#[derive(Debug)]
pub struct JsonpChunkLoadingPlugin;

impl Plugin for JsonpChunkLoadingPlugin {
    fn name(&self) -> &'static str {
        "JsonpChunkLoadingPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compilation_hooks
            .additional_tree_runtime_requirements
            .tap(jsonp_runtime_hook::new());
        Ok(())
    }
}

/// JSONP 运行时模块
#[derive(Debug)]
pub struct JsonpChunkLoadingRuntimeModule {
    runtime_requirements: RuntimeGlobals,
}

impl RuntimeModule for JsonpChunkLoadingRuntimeModule {
    fn name(&self) -> Identifier {
        "__webpack_require__.l".into()
    }
    
    fn generate(&self, compilation: &Compilation) -> Result<BoxSource> {
        let template = JsonpTemplate::new(&compilation.options);
        let runtime_code = template.render_chunk_loading_runtime()?;
        Ok(RawSource::from(runtime_code).boxed())
    }
}
```

### 模块联邦插件

### rspack_plugin_mf - 模块联邦插件

```rust
/// 模块联邦插件
#[derive(Debug)]
pub struct ModuleFederationPlugin {
    options: ModuleFederationOptions,
}

#[derive(Debug, Clone)]
pub struct ModuleFederationOptions {
    /// 应用名称
    pub name: String,
    /// 文件名
    pub filename: Option<String>,
    /// 暴露的模块
    pub exposes: HashMap<String, ExposeOptions>,
    /// 远程应用
    pub remotes: HashMap<String, RemoteOptions>,
    /// 共享模块
    pub shared: HashMap<String, SharedOptions>,
    /// 库配置
    pub library: Option<LibraryOptions>,
}

impl Plugin for ModuleFederationPlugin {
    fn name(&self) -> &'static str {
        "ModuleFederationPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 添加容器插件
        if !self.options.exposes.is_empty() {
            let container_plugin = ContainerPlugin::new(
                self.options.name.clone(),
                self.options.exposes.clone(),
                self.options.library.clone(),
            );
            container_plugin.apply(ctx)?;
        }
        
        // 添加容器引用插件
        if !self.options.remotes.is_empty() {
            let container_ref_plugin = ContainerReferencePlugin::new(
                self.options.remotes.clone(),
            );
            container_ref_plugin.apply(ctx)?;
        }
        
        // 添加共享模块插件
        if !self.options.shared.is_empty() {
            let share_plugin = SharePlugin::new(
                self.options.shared.clone(),
            );
            share_plugin.apply(ctx)?;
        }
        
        Ok(())
    }
}
```

## 工具和实用插件

### rspack_plugin_copy - 文件复制插件

```rust
/// 文件复制插件
#[derive(Debug)]
pub struct CopyPlugin {
    patterns: Vec<CopyPattern>,
    options: CopyOptions,
}

#[derive(Debug, Clone)]
pub struct CopyPattern {
    /// 源路径模式
    pub from: String,
    /// 目标路径
    pub to: Option<String>,
    /// 上下文路径
    pub context: Option<String>,
    /// Glob 选项
    pub glob_options: GlobOptions,
    /// 转换函数
    pub transform: Option<TransformFunction>,
    /// 过滤函数
    pub filter: Option<FilterFunction>,
}

impl Plugin for CopyPlugin {
    fn name(&self) -> &'static str {
        "CopyPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compilation_hooks
            .process_assets
            .tap(copy_assets_hook::new(&self.patterns, &self.options));
        Ok(())
    }
}

/// 复制文件资源
fn copy_assets(
    compilation: &mut Compilation,
    patterns: &[CopyPattern],
) -> Result<()> {
    for pattern in patterns {
        let files = glob::glob(&pattern.from)?;
        
        for file_path in files {
            let file_path = file_path?;
            let content = fs::read(&file_path)?;
            
            // 应用转换
            let content = if let Some(transform) = &pattern.transform {
                transform(content, file_path.clone())?
            } else {
                content
            };
            
            // 计算目标路径
            let target_path = pattern.to
                .as_ref()
                .unwrap_or(&file_path.file_name().unwrap().to_string_lossy())
                .clone();
            
            // 发射资源
            compilation.emit_asset(
                target_path,
                RawSource::from(content).boxed(),
            );
        }
    }
    
    Ok(())
}
```

### rspack_plugin_html - HTML 处理插件

```rust
/// HTML 插件
#[derive(Debug)]
pub struct HtmlPlugin {
    options: HtmlPluginOptions,
}

#[derive(Debug, Clone)]
pub struct HtmlPluginOptions {
    /// 模板路径
    pub template: Option<String>,
    /// 文件名
    pub filename: String,
    /// 页面标题
    pub title: Option<String>,
    /// Meta 标签
    pub meta: HashMap<String, String>,
    /// 包含的 chunks
    pub chunks: Option<Vec<String>>,
    /// 排除的 chunks
    pub exclude_chunks: Option<Vec<String>>,
    /// 是否注入资源
    pub inject: HtmlInjectOption,
    /// 是否压缩
    pub minify: bool,
}

impl Plugin for HtmlPlugin {
    fn name(&self) -> &'static str {
        "HtmlPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compilation_hooks
            .process_assets
            .tap(html_process_hook::new(&self.options));
        Ok(())
    }
}

/// HTML 模板生成
fn generate_html(
    compilation: &Compilation,
    options: &HtmlPluginOptions,
) -> Result<String> {
    let mut html = if let Some(template_path) = &options.template {
        fs::read_to_string(template_path)?
    } else {
        DEFAULT_HTML_TEMPLATE.to_string()
    };
    
    // 替换标题
    if let Some(title) = &options.title {
        html = html.replace("<title></title>", &format!("<title>{}</title>", title));
    }
    
    // 注入 meta 标签
    let meta_tags = options.meta
        .iter()
        .map(|(name, content)| format!(r#"<meta name="{}" content="{}">"#, name, content))
        .collect::<Vec<_>>()
        .join("\n  ");
    
    html = html.replace("</head>", &format!("  {}\n</head>", meta_tags));
    
    // 注入资源
    if options.inject != HtmlInjectOption::False {
        let (css_tags, js_tags) = generate_asset_tags(compilation, options)?;
        
        match options.inject {
            HtmlInjectOption::Head => {
                html = html.replace("</head>", &format!("  {}\n  {}\n</head>", css_tags, js_tags));
            }
            HtmlInjectOption::Body => {
                html = html.replace("</body>", &format!("  {}\n  {}\n</body>", css_tags, js_tags));
            }
            _ => {}
        }
    }
    
    // 压缩 HTML
    if options.minify {
        html = minify_html(&html)?;
    }
    
    Ok(html)
}
```

## 高级功能插件

### rspack_plugin_wasm - WebAssembly 支持插件

```rust
/// WebAssembly 插件
#[derive(Debug)]
pub struct WasmPlugin;

impl Plugin for WasmPlugin {
    fn name(&self) -> &'static str {
        "WasmPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 注册 WASM 解析器和生成器
        ctx.normal_module_factory_hooks
            .create_parser
            .tap(create_wasm_parser_hook::new());
            
        ctx.normal_module_factory_hooks
            .create_generator
            .tap(create_wasm_generator_hook::new());
            
        // 注册 WASM 加载运行时
        ctx.compilation_hooks
            .additional_tree_runtime_requirements
            .tap(wasm_runtime_hook::new());
            
        Ok(())
    }
}

/// WASM 解析器和生成器
pub struct WasmParserAndGenerator;

impl ParserAndGenerator for WasmParserAndGenerator {
    fn source_types(&self) -> &[SourceType] {
        &[SourceType::Wasm]
    }
    
    fn parse(&mut self, parse_context: ParseContext) -> Result<ParseResult> {
        let wasm_bytes = parse_context.source.source();
        let wasm_module = wasmparser::validate(&wasm_bytes)?;
        
        // 分析 WASM 导入和导出
        let mut dependencies = Vec::new();
        let mut exports = Vec::new();
        
        for payload in wasmparser::Parser::new(0).parse_all(&wasm_bytes) {
            match payload? {
                wasmparser::Payload::ImportSection(imports) => {
                    for import in imports {
                        let import = import?;
                        let dep = WasmImportDependency::new(
                            import.module.to_string(),
                            import.name.to_string(),
                        );
                        dependencies.push(Box::new(dep) as BoxDependency);
                    }
                }
                wasmparser::Payload::ExportSection(exports_section) => {
                    for export in exports_section {
                        let export = export?;
                        exports.push(export.name.to_string());
                    }
                }
                _ => {}
            }
        }
        
        Ok(ParseResult {
            dependencies,
            source: Some(parse_context.source),
            side_effects: false,
        })
    }
    
    fn generate(
        &self,
        source: &dyn Source,
        module: &BoxModule,
        generate_context: &mut GenerateContext,
    ) -> Result<GenerateResult> {
        let wasm_bytes = source.source();
        let filename = format!("{}.wasm", generate_hash(&wasm_bytes));
        
        // 发射 WASM 文件
        generate_context.emit_asset(
            filename.clone(),
            RawSource::from(wasm_bytes).boxed(),
        );
        
        // 生成 WASM 加载代码
        let loader_code = format!(
            r#"
            module.exports = __webpack_require__.loadWasm(
                __webpack_require__.p + "{}"
            );
            "#,
            filename
        );
        
        Ok(GenerateResult {
            inner: GenerateResultInner::Source(
                RawSource::from(loader_code).boxed()
            ),
            runtime_requirements: RuntimeGlobals::from([
                RuntimeGlobal::LoadWasm,
                RuntimeGlobal::PublicPath,
            ]),
        })
    }
}
```

### rspack_plugin_worker - Web Worker 支持插件

```rust
/// Web Worker 插件
#[derive(Debug)]
pub struct WorkerPlugin {
    options: WorkerPluginOptions,
}

#[derive(Debug, Clone)]
pub struct WorkerPluginOptions {
    /// Worker 类型
    pub worker_types: Vec<WorkerType>,
    /// 输出文件名
    pub filename: Option<String>,
    /// 是否内联
    pub inline: bool,
}

#[derive(Debug, Clone)]
pub enum WorkerType {
    WebWorker,
    ServiceWorker,
    SharedWorker,
}

impl Plugin for WorkerPlugin {
    fn name(&self) -> &'static str {
        "WorkerPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        // 解析 Worker 构造函数调用
        ctx.normal_module_factory_hooks
            .parser
            .tap(worker_parser_hook::new(&self.options));
            
        // 编译 Worker 入口
        ctx.compilation_hooks
            .child_compiler
            .tap(worker_child_compiler_hook::new(&self.options));
            
        Ok(())
    }
}

/// Worker 依赖
#[derive(Debug, Clone)]
pub struct WorkerDependency {
    request: String,
    worker_type: WorkerType,
    span: DependencyLocation,
}

impl Dependency for WorkerDependency {
    fn dependency_type(&self) -> &DependencyType {
        &DependencyType::Worker
    }
    
    fn category(&self) -> &DependencyCategory {
        &DependencyCategory::Worker
    }
    
    fn resource_identifier(&self) -> Option<&str> {
        Some(&self.request)
    }
}

/// 创建 Worker 子编译器
fn create_worker_child_compiler(
    compilation: &Compilation,
    worker_dep: &WorkerDependency,
    options: &WorkerPluginOptions,
) -> Result<Compiler> {
    let mut child_options = compilation.options.clone();
    
    // 配置 Worker 特定选项
    child_options.output.filename = options.filename
        .clone()
        .unwrap_or_else(|| "[name].worker.js".to_string());
    child_options.target = vec!["webworker".to_string()];
    
    // 创建子编译器
    let child_compiler = Compiler::new(
        child_options,
        vec![], // 插件列表
        compilation.output_filesystem.clone(),
        compilation.input_filesystem.clone(),
    )?;
    
    Ok(child_compiler)
}
```

## 插件开发指南

### 创建自定义插件

```rust
use rspack_core::*;

/// 自定义插件示例
#[derive(Debug)]
pub struct MyCustomPlugin {
    name: String,
    options: MyPluginOptions,
}

#[derive(Debug, Clone)]
pub struct MyPluginOptions {
    pub enabled: bool,
    pub pattern: String,
    pub replacement: String,
}

impl MyCustomPlugin {
    pub fn new(options: MyPluginOptions) -> Self {
        Self {
            name: "MyCustomPlugin".to_string(),
            options,
        }
    }
}

impl Plugin for MyCustomPlugin {
    fn name(&self) -> &'static str {
        "MyCustomPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        if !self.options.enabled {
            return Ok(());
        }
        
        // 注册编译器钩子
        ctx.compiler_hooks.compilation.tap(
            compilation_hook::new(self)
        );
        
        // 注册编译钩子
        ctx.compilation_hooks.process_assets.tap(
            process_assets_hook::new(&self.options)
        );
        
        Ok(())
    }
}

/// 处理资源的钩子函数
fn process_assets_hook(options: &MyPluginOptions) -> impl Fn(&mut CompilationAssets) + Send + Sync {
    let pattern = options.pattern.clone();
    let replacement = options.replacement.clone();
    
    move |assets| {
        for (name, asset) in assets.iter_mut() {
            if name.contains(&pattern) {
                let content = asset.source.source();
                let new_content = content.replace(&pattern, &replacement);
                asset.source = RawSource::from(new_content).boxed();
            }
        }
    }
}
```

### 插件测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use rspack_testing::*;
    
    #[test]
    fn test_my_custom_plugin() {
        let test_case = TestCase::new("my-plugin-test")
            .entry("./src/index.js")
            .plugin(MyCustomPlugin::new(MyPluginOptions {
                enabled: true,
                pattern: "OLD_VALUE".to_string(),
                replacement: "NEW_VALUE".to_string(),
            }))
            .expect_asset("main.js", |content| {
                assert!(content.contains("NEW_VALUE"));
                assert!(!content.contains("OLD_VALUE"));
            });
            
        test_case.run().unwrap();
    }
}
```

Rspack 的插件生态系统设计精良，提供了完整的功能覆盖和良好的扩展性。统一的插件接口、丰富的钩子系统以及模块化的设计使得开发者能够轻松创建自定义插件来满足特定需求。