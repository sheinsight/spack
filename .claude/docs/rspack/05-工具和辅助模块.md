# Rspack 工具和辅助模块 API 文档

## 工具库概述

Rspack 包含多个工具和辅助 crate，提供构建过程中需要的各种基础功能和实用工具。

## 文件系统抽象

### rspack_fs - 文件系统抽象层

提供统一的文件系统接口，支持内存文件系统、原生文件系统等多种实现。

```rust
/// 文件系统 trait
pub trait FileSystem: Debug + Send + Sync {
    /// 读取文件
    fn read(&self, path: &Path) -> Result<Vec<u8>, ReadError>;
    
    /// 获取文件元数据
    fn metadata(&self, path: &Path) -> Result<FileMetadata, ReadError>;
    
    /// 读取目录
    fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>, ReadError>;
    
    /// 读取链接
    fn read_link(&self, path: &Path) -> Result<PathBuf, ReadError>;
}

/// 可写文件系统 trait
pub trait WritableFileSystem: FileSystem {
    /// 写入文件
    fn write(&self, path: &Path, data: &[u8]) -> Result<(), WriteError>;
    
    /// 创建目录
    fn create_dir_all(&self, path: &Path) -> Result<(), WriteError>;
    
    /// 删除文件
    fn remove_file(&self, path: &Path) -> Result<(), WriteError>;
    
    /// 删除目录
    fn remove_dir_all(&self, path: &Path) -> Result<(), WriteError>;
}

/// 原生文件系统实现
#[derive(Debug)]
pub struct NativeFileSystem;

impl FileSystem for NativeFileSystem {
    fn read(&self, path: &Path) -> Result<Vec<u8>, ReadError> {
        std::fs::read(path).map_err(ReadError::from)
    }
    
    fn metadata(&self, path: &Path) -> Result<FileMetadata, ReadError> {
        let metadata = std::fs::metadata(path)?;
        Ok(FileMetadata {
            is_file: metadata.is_file(),
            is_dir: metadata.is_dir(),
            is_symlink: metadata.file_type().is_symlink(),
            size: metadata.len(),
            modified: metadata.modified().ok(),
            created: metadata.created().ok(),
        })
    }
    
    fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>, ReadError> {
        let entries = std::fs::read_dir(path)?
            .collect::<Result<Vec<_>, _>>()?
            .into_iter()
            .map(|entry| {
                let path = entry.path();
                let metadata = entry.metadata()?;
                Ok(DirEntry {
                    path,
                    file_type: if metadata.is_file() {
                        FileType::File
                    } else if metadata.is_dir() {
                        FileType::Directory
                    } else {
                        FileType::Symlink
                    },
                })
            })
            .collect::<Result<Vec<_>, std::io::Error>>()?;
        Ok(entries)
    }
}

/// 内存文件系统实现
#[derive(Debug)]
pub struct MemoryFileSystem {
    files: Arc<RwLock<HashMap<PathBuf, Vec<u8>>>>,
    directories: Arc<RwLock<HashSet<PathBuf>>>,
}

impl MemoryFileSystem {
    pub fn new() -> Self {
        Self {
            files: Arc::new(RwLock::new(HashMap::new())),
            directories: Arc::new(RwLock::new(HashSet::new())),
        }
    }
    
    pub fn set_file(&self, path: PathBuf, content: Vec<u8>) {
        let mut files = self.files.write().unwrap();
        files.insert(path.clone(), content);
        
        // 确保父目录存在
        if let Some(parent) = path.parent() {
            let mut directories = self.directories.write().unwrap();
            directories.insert(parent.to_path_buf());
        }
    }
    
    pub fn get_file(&self, path: &Path) -> Option<Vec<u8>> {
        let files = self.files.read().unwrap();
        files.get(path).cloned()
    }
}

/// 文件监视器
pub mod watcher {
    use super::*;
    
    /// 文件监视器 trait
    pub trait Watcher: Send + Sync {
        /// 开始监视
        fn watch(&mut self, paths: Vec<PathBuf>) -> Result<(), WatchError>;
        
        /// 停止监视
        fn stop(&mut self) -> Result<(), WatchError>;
        
        /// 获取变化事件
        fn poll_events(&mut self) -> Result<Vec<WatchEvent>, WatchError>;
    }
    
    /// 监视事件
    #[derive(Debug, Clone)]
    pub struct WatchEvent {
        pub path: PathBuf,
        pub kind: WatchEventKind,
    }
    
    #[derive(Debug, Clone)]
    pub enum WatchEventKind {
        Create,
        Modify,
        Delete,
        Rename { from: PathBuf, to: PathBuf },
    }
    
    /// 磁盘监视器实现
    #[derive(Debug)]
    pub struct DiskWatcher {
        watcher: notify::RecommendedWatcher,
        receiver: mpsc::Receiver<notify::Result<notify::Event>>,
    }
    
    impl DiskWatcher {
        pub fn new() -> Result<Self, WatchError> {
            let (tx, receiver) = mpsc::channel();
            let watcher = notify::Watcher::new(
                move |res| {
                    if let Err(err) = tx.send(res) {
                        eprintln!("监视器发送事件失败: {}", err);
                    }
                },
                notify::Config::default()
            )?;
            
            Ok(Self { watcher, receiver })
        }
    }
    
    impl Watcher for DiskWatcher {
        fn watch(&mut self, paths: Vec<PathBuf>) -> Result<(), WatchError> {
            for path in paths {
                self.watcher.watch(&path, notify::RecursiveMode::Recursive)?;
            }
            Ok(())
        }
        
        fn poll_events(&mut self) -> Result<Vec<WatchEvent>, WatchError> {
            let mut events = Vec::new();
            
            while let Ok(event) = self.receiver.try_recv() {
                match event {
                    Ok(notify_event) => {
                        for path in notify_event.paths {
                            let kind = match notify_event.kind {
                                notify::EventKind::Create(_) => WatchEventKind::Create,
                                notify::EventKind::Modify(_) => WatchEventKind::Modify,
                                notify::EventKind::Remove(_) => WatchEventKind::Delete,
                                _ => continue,
                            };
                            
                            events.push(WatchEvent { path, kind });
                        }
                    }
                    Err(err) => {
                        eprintln!("监视器事件错误: {}", err);
                    }
                }
            }
            
            Ok(events)
        }
    }
}
```

## 哈希计算

### rspack_hash - 哈希工具

提供各种哈希算法的统一接口。

```rust
/// 哈希器 trait
pub trait Hasher: Debug + Send + Sync {
    /// 写入数据
    fn write(&mut self, bytes: &[u8]);
    
    /// 写入字符串
    fn write_str(&mut self, s: &str) {
        self.write(s.as_bytes());
    }
    
    /// 写入数字
    fn write_u64(&mut self, n: u64) {
        self.write(&n.to_le_bytes());
    }
    
    /// 完成并获取哈希值
    fn finish(&self) -> String;
    
    /// 获取哈希长度
    fn digest_length(&self) -> usize;
}

/// MD5 哈希器
#[derive(Debug)]
pub struct Md5Hasher {
    hasher: md5::Context,
}

impl Md5Hasher {
    pub fn new() -> Self {
        Self {
            hasher: md5::Context::new(),
        }
    }
}

impl Hasher for Md5Hasher {
    fn write(&mut self, bytes: &[u8]) {
        self.hasher.consume(bytes);
    }
    
    fn finish(&self) -> String {
        let digest = self.hasher.compute();
        format!("{:x}", digest)
    }
    
    fn digest_length(&self) -> usize {
        32 // MD5 产生32个十六进制字符
    }
}

/// SHA256 哈希器
#[derive(Debug)]
pub struct Sha256Hasher {
    hasher: sha2::Sha256,
}

impl Sha256Hasher {
    pub fn new() -> Self {
        Self {
            hasher: sha2::Sha256::new(),
        }
    }
}

impl Hasher for Sha256Hasher {
    fn write(&mut self, bytes: &[u8]) {
        use sha2::Digest;
        self.hasher.update(bytes);
    }
    
    fn finish(&self) -> String {
        use sha2::Digest;
        let result = self.hasher.finalize_reset();
        format!("{:x}", result)
    }
    
    fn digest_length(&self) -> usize {
        64 // SHA256 产生64个十六进制字符
    }
}

/// xxHash 哈希器（高性能）
#[derive(Debug)]
pub struct XxHasher {
    hasher: xxhash_rust::xxh3::Xxh3,
}

impl XxHasher {
    pub fn new() -> Self {
        Self {
            hasher: xxhash_rust::xxh3::Xxh3::new(),
        }
    }
    
    pub fn with_seed(seed: u64) -> Self {
        Self {
            hasher: xxhash_rust::xxh3::Xxh3::with_seed(seed),
        }
    }
}

impl Hasher for XxHasher {
    fn write(&mut self, bytes: &[u8]) {
        self.hasher.update(bytes);
    }
    
    fn finish(&self) -> String {
        format!("{:016x}", self.hasher.digest())
    }
    
    fn digest_length(&self) -> usize {
        16 // xxHash64 产生16个十六进制字符
    }
}

/// 哈希工厂
pub struct HashFactory;

impl HashFactory {
    /// 创建指定类型的哈希器
    pub fn create_hasher(hash_type: &str) -> Result<Box<dyn Hasher>, HashError> {
        match hash_type.to_lowercase().as_str() {
            "md5" => Ok(Box::new(Md5Hasher::new())),
            "sha256" => Ok(Box::new(Sha256Hasher::new())),
            "xxhash" => Ok(Box::new(XxHasher::new())),
            _ => Err(HashError::UnsupportedHashType(hash_type.to_string())),
        }
    }
    
    /// 计算字节数组的哈希
    pub fn hash_bytes(data: &[u8], hash_type: &str) -> Result<String, HashError> {
        let mut hasher = Self::create_hasher(hash_type)?;
        hasher.write(data);
        Ok(hasher.finish())
    }
    
    /// 计算字符串的哈希
    pub fn hash_string(s: &str, hash_type: &str) -> Result<String, HashError> {
        Self::hash_bytes(s.as_bytes(), hash_type)
    }
}
```

## 路径处理

### rspack_paths - 路径工具

提供跨平台的路径处理工具。

```rust
/// 路径工具集
pub struct PathUtils;

impl PathUtils {
    /// 规范化路径
    pub fn normalize<P: AsRef<Path>>(path: P) -> PathBuf {
        let path = path.as_ref();
        let mut components = Vec::new();
        
        for component in path.components() {
            match component {
                Component::Normal(name) => components.push(name),
                Component::ParentDir => {
                    if !components.is_empty() {
                        components.pop();
                    }
                }
                Component::CurDir => {} // 忽略 . 组件
                Component::RootDir | Component::Prefix(_) => {
                    components.clear();
                    components.push(component.as_os_str());
                }
            }
        }
        
        components.iter().collect()
    }
    
    /// 获取相对路径
    pub fn relative<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> PathBuf {
        let from = from.as_ref().canonicalize().unwrap_or_else(|_| from.as_ref().to_path_buf());
        let to = to.as_ref().canonicalize().unwrap_or_else(|_| to.as_ref().to_path_buf());
        
        pathdiff::diff_paths(&to, &from).unwrap_or_else(|| to.clone())
    }
    
    /// 检查路径是否为绝对路径
    pub fn is_absolute<P: AsRef<Path>>(path: P) -> bool {
        path.as_ref().is_absolute()
    }
    
    /// 转换为 Unix 风格路径
    pub fn to_unix_path<P: AsRef<Path>>(path: P) -> String {
        path.as_ref()
            .to_string_lossy()
            .replace('\\', "/")
    }
    
    /// 解析请求路径
    pub fn parse_request(request: &str) -> RequestInfo {
        // 解析 loader! 前缀
        let mut loaders = Vec::new();
        let mut parts = request.split('!');
        let mut resource = parts.next_back().unwrap_or(request);
        
        for loader_request in parts {
            loaders.push(loader_request.to_string());
        }
        
        // 解析查询参数和片段
        let mut query = None;
        let mut fragment = None;
        
        if let Some(query_start) = resource.find('?') {
            let (resource_part, query_part) = resource.split_at(query_start);
            resource = resource_part;
            
            if let Some(fragment_start) = query_part.find('#') {
                let (query_part, fragment_part) = query_part.split_at(fragment_start);
                query = Some(query_part[1..].to_string()); // 跳过 '?'
                fragment = Some(fragment_part[1..].to_string()); // 跳过 '#'
            } else {
                query = Some(query_part[1..].to_string()); // 跳过 '?'
            }
        } else if let Some(fragment_start) = resource.find('#') {
            let (resource_part, fragment_part) = resource.split_at(fragment_start);
            resource = resource_part;
            fragment = Some(fragment_part[1..].to_string()); // 跳过 '#'
        }
        
        RequestInfo {
            loaders,
            resource: resource.to_string(),
            query,
            fragment,
        }
    }
}

/// 请求信息
#[derive(Debug, Clone)]
pub struct RequestInfo {
    pub loaders: Vec<String>,
    pub resource: String,
    pub query: Option<String>,
    pub fragment: Option<String>,
}

impl RequestInfo {
    /// 重新构建请求字符串
    pub fn to_request_string(&self) -> String {
        let mut request = String::new();
        
        // 添加加载器
        for loader in &self.loaders {
            request.push_str(loader);
            request.push('!');
        }
        
        // 添加资源
        request.push_str(&self.resource);
        
        // 添加查询参数
        if let Some(query) = &self.query {
            request.push('?');
            request.push_str(query);
        }
        
        // 添加片段
        if let Some(fragment) = &self.fragment {
            request.push('#');
            request.push_str(fragment);
        }
        
        request
    }
}
```

## 错误处理

### rspack_error - 错误处理系统

提供统一的错误处理和诊断信息。

```rust
/// Rspack 错误类型
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("IO 错误: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("解析错误: {message}")]
    Parse { message: String, location: Option<SourceLocation> },
    
    #[error("模块未找到: {request} 在 {context}")]
    ModuleNotFound { request: String, context: String },
    
    #[error("循环依赖: {cycle:?}")]
    CircularDependency { cycle: Vec<String> },
    
    #[error("插件错误: {plugin_name}: {message}")]
    Plugin { plugin_name: String, message: String },
    
    #[error("编译错误: {0}")]
    Compilation(#[from] CompilationError),
    
    #[error("内部错误: {0}")]
    Internal(String),
}

/// 编译错误
#[derive(Debug, thiserror::Error)]
pub enum CompilationError {
    #[error("入口点未找到: {entry}")]
    EntryNotFound { entry: String },
    
    #[error("模块构建失败: {module}")]
    ModuleBuildFailed { module: String, source: Box<Error> },
    
    #[error("代码生成失败: {module}")]
    CodeGenerationFailed { module: String, source: Box<Error> },
    
    #[error("资源发射失败: {asset}")]
    AssetEmitFailed { asset: String, source: Box<Error> },
}

/// 源码位置信息
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SourceLocation {
    pub file: String,
    pub line: u32,
    pub column: u32,
}

/// 诊断信息
#[derive(Debug, Clone)]
pub struct Diagnostic {
    pub severity: Severity,
    pub message: String,
    pub location: Option<SourceLocation>,
    pub source_code: Option<String>,
    pub help: Option<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Severity {
    Error,
    Warning,
    Info,
    Hint,
}

/// 错误发射器
pub trait ErrorEmitter: Send + Sync {
    /// 发射错误
    fn emit_error(&self, error: Error);
    
    /// 发射警告
    fn emit_warning(&self, warning: Error);
    
    /// 发射诊断信息
    fn emit_diagnostic(&self, diagnostic: Diagnostic);
}

/// 控制台错误发射器
#[derive(Debug)]
pub struct ConsoleErrorEmitter {
    colors: bool,
}

impl ConsoleErrorEmitter {
    pub fn new(colors: bool) -> Self {
        Self { colors }
    }
}

impl ErrorEmitter for ConsoleErrorEmitter {
    fn emit_error(&self, error: Error) {
        if self.colors {
            eprintln!("\x1b[31m错误:\x1b[0m {}", error);
        } else {
            eprintln!("错误: {}", error);
        }
    }
    
    fn emit_warning(&self, warning: Error) {
        if self.colors {
            eprintln!("\x1b[33m警告:\x1b[0m {}", warning);
        } else {
            eprintln!("警告: {}", warning);
        }
    }
    
    fn emit_diagnostic(&self, diagnostic: Diagnostic) {
        let severity_str = match diagnostic.severity {
            Severity::Error => if self.colors { "\x1b[31m错误\x1b[0m" } else { "错误" },
            Severity::Warning => if self.colors { "\x1b[33m警告\x1b[0m" } else { "警告" },
            Severity::Info => if self.colors { "\x1b[34m信息\x1b[0m" } else { "信息" },
            Severity::Hint => if self.colors { "\x1b[36m提示\x1b[0m" } else { "提示" },
        };
        
        if let Some(location) = &diagnostic.location {
            eprintln!("{}[{}:{}:{}]: {}", 
                severity_str, location.file, location.line, location.column, diagnostic.message);
        } else {
            eprintln!("{}: {}", severity_str, diagnostic.message);
        }
        
        if let Some(help) = &diagnostic.help {
            if self.colors {
                eprintln!("  \x1b[36m帮助:\x1b[0m {}", help);
            } else {
                eprintln!("  帮助: {}", help);
            }
        }
    }
}
```

## 性能追踪

### rspack_tracing - 性能追踪

提供性能分析和追踪功能。

```rust
/// 追踪器 trait
pub trait Tracer: Send + Sync {
    /// 开始跟踪
    fn begin_trace(&self, name: &str) -> TraceId;
    
    /// 结束跟踪
    fn end_trace(&self, trace_id: TraceId);
    
    /// 添加事件
    fn add_event(&self, name: &str, data: serde_json::Value);
    
    /// 设置元数据
    fn set_metadata(&self, key: &str, value: serde_json::Value);
}

/// 跟踪 ID
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TraceId(u64);

/// 性能计数器
#[derive(Debug)]
pub struct PerfCounter {
    name: String,
    start_time: Instant,
    end_time: Option<Instant>,
}

impl PerfCounter {
    pub fn new(name: String) -> Self {
        Self {
            name,
            start_time: Instant::now(),
            end_time: None,
        }
    }
    
    pub fn stop(&mut self) -> Duration {
        self.end_time = Some(Instant::now());
        self.duration()
    }
    
    pub fn duration(&self) -> Duration {
        let end_time = self.end_time.unwrap_or_else(Instant::now);
        end_time - self.start_time
    }
}

/// Chrome DevTools 追踪器
#[derive(Debug)]
pub struct ChromeTracer {
    events: Arc<Mutex<Vec<ChromeEvent>>>,
    next_id: AtomicU64,
}

#[derive(Debug, Serialize)]
struct ChromeEvent {
    name: String,
    cat: String,
    ph: String, // 阶段：B(开始), E(结束), X(完整), i(即时)
    ts: u64,    // 时间戳（微秒）
    dur: Option<u64>, // 持续时间（微秒）
    pid: u32,   // 进程 ID
    tid: u32,   // 线程 ID
    args: serde_json::Value,
}

impl ChromeTracer {
    pub fn new() -> Self {
        Self {
            events: Arc::new(Mutex::new(Vec::new())),
            next_id: AtomicU64::new(1),
        }
    }
    
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<(), std::io::Error> {
        let events = self.events.lock().unwrap();
        let json = serde_json::to_string_pretty(&*events)?;
        std::fs::write(path, json)?;
        Ok(())
    }
}

impl Tracer for ChromeTracer {
    fn begin_trace(&self, name: &str) -> TraceId {
        let trace_id = TraceId(self.next_id.fetch_add(1, Ordering::SeqCst));
        let mut events = self.events.lock().unwrap();
        
        events.push(ChromeEvent {
            name: name.to_string(),
            cat: "rspack".to_string(),
            ph: "B".to_string(),
            ts: timestamp_micros(),
            dur: None,
            pid: std::process::id(),
            tid: thread_id(),
            args: serde_json::json!({"trace_id": trace_id.0}),
        });
        
        trace_id
    }
    
    fn end_trace(&self, trace_id: TraceId) {
        let mut events = self.events.lock().unwrap();
        
        events.push(ChromeEvent {
            name: "".to_string(),
            cat: "rspack".to_string(),
            ph: "E".to_string(),
            ts: timestamp_micros(),
            dur: None,
            pid: std::process::id(),
            tid: thread_id(),
            args: serde_json::json!({"trace_id": trace_id.0}),
        });
    }
    
    fn add_event(&self, name: &str, data: serde_json::Value) {
        let mut events = self.events.lock().unwrap();
        
        events.push(ChromeEvent {
            name: name.to_string(),
            cat: "rspack".to_string(),
            ph: "i".to_string(),
            ts: timestamp_micros(),
            dur: None,
            pid: std::process::id(),
            tid: thread_id(),
            args: data,
        });
    }
    
    fn set_metadata(&self, key: &str, value: serde_json::Value) {
        let mut events = self.events.lock().unwrap();
        
        events.push(ChromeEvent {
            name: key.to_string(),
            cat: "metadata".to_string(),
            ph: "M".to_string(),
            ts: timestamp_micros(),
            dur: None,
            pid: std::process::id(),
            tid: thread_id(),
            args: value,
        });
    }
}

/// 获取当前时间戳（微秒）
fn timestamp_micros() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_micros() as u64
}

/// 获取当前线程 ID
fn thread_id() -> u32 {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    std::thread::current().id().hash(&mut hasher);
    hasher.finish() as u32
}

/// 追踪宏
#[macro_export]
macro_rules! trace {
    ($tracer:expr, $name:expr, $block:block) => {{
        let trace_id = $tracer.begin_trace($name);
        let result = $block;
        $tracer.end_trace(trace_id);
        result
    }};
}
```

## 正则表达式工具

### rspack_regex - 正则表达式优化

提供高性能的正则表达式匹配和编译。

```rust
/// 正则表达式匹配器
pub trait RegexMatcher: Debug + Send + Sync {
    /// 测试字符串是否匹配
    fn test(&self, text: &str) -> bool;
    
    /// 查找所有匹配
    fn find_all(&self, text: &str) -> Vec<Match>;
    
    /// 替换匹配的文本
    fn replace_all(&self, text: &str, replacement: &str) -> String;
}

/// 匹配结果
#[derive(Debug, Clone)]
pub struct Match {
    pub start: usize,
    pub end: usize,
    pub text: String,
}

/// 编译后的正则表达式
#[derive(Debug)]
pub struct CompiledRegex {
    regex: regex::Regex,
    pattern: String,
}

impl CompiledRegex {
    /// 编译正则表达式
    pub fn new(pattern: &str) -> Result<Self, regex::Error> {
        let regex = regex::Regex::new(pattern)?;
        Ok(Self {
            regex,
            pattern: pattern.to_string(),
        })
    }
    
    /// 获取原始模式
    pub fn pattern(&self) -> &str {
        &self.pattern
    }
}

impl RegexMatcher for CompiledRegex {
    fn test(&self, text: &str) -> bool {
        self.regex.is_match(text)
    }
    
    fn find_all(&self, text: &str) -> Vec<Match> {
        self.regex
            .find_iter(text)
            .map(|m| Match {
                start: m.start(),
                end: m.end(),
                text: m.as_str().to_string(),
            })
            .collect()
    }
    
    fn replace_all(&self, text: &str, replacement: &str) -> String {
        self.regex.replace_all(text, replacement).to_string()
    }
}

/// 正则表达式缓存
#[derive(Debug)]
pub struct RegexCache {
    cache: Arc<RwLock<HashMap<String, Arc<CompiledRegex>>>>,
}

impl RegexCache {
    pub fn new() -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// 获取或编译正则表达式
    pub fn get_or_compile(&self, pattern: &str) -> Result<Arc<CompiledRegex>, regex::Error> {
        // 首先尝试从缓存读取
        {
            let cache = self.cache.read().unwrap();
            if let Some(regex) = cache.get(pattern) {
                return Ok(regex.clone());
            }
        }
        
        // 编译新的正则表达式
        let compiled = Arc::new(CompiledRegex::new(pattern)?);
        
        // 写入缓存
        {
            let mut cache = self.cache.write().unwrap();
            cache.insert(pattern.to_string(), compiled.clone());
        }
        
        Ok(compiled)
    }
    
    /// 清除缓存
    pub fn clear(&self) {
        let mut cache = self.cache.write().unwrap();
        cache.clear();
    }
    
    /// 获取缓存统计
    pub fn stats(&self) -> CacheStats {
        let cache = self.cache.read().unwrap();
        CacheStats {
            size: cache.len(),
            memory_usage: cache.len() * std::mem::size_of::<(String, Arc<CompiledRegex>)>(),
        }
    }
}

#[derive(Debug)]
pub struct CacheStats {
    pub size: usize,
    pub memory_usage: usize,
}
```

## 并发工具

### rspack_futures - 异步工具

提供异步编程的工具和扩展。

```rust
/// 作用域任务管理器
pub struct ScopedTaskRunner {
    runtime: tokio::runtime::Runtime,
    tasks: Arc<Mutex<Vec<JoinHandle<()>>>>,
}

impl ScopedTaskRunner {
    /// 创建新的任务管理器
    pub fn new() -> Result<Self, std::io::Error> {
        let runtime = tokio::runtime::Runtime::new()?;
        Ok(Self {
            runtime,
            tasks: Arc::new(Mutex::new(Vec::new())),
        })
    }
    
    /// 生成新任务
    pub fn spawn<F, T>(&self, future: F) -> JoinHandle<T>
    where
        F: Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        self.runtime.spawn(future)
    }
    
    /// 生成阻塞任务
    pub fn spawn_blocking<F, T>(&self, func: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        self.runtime.spawn_blocking(func)
    }
    
    /// 等待所有任务完成
    pub async fn wait_all(&self) -> Result<(), JoinError> {
        let tasks = {
            let mut tasks = self.tasks.lock().unwrap();
            std::mem::take(&mut *tasks)
        };
        
        for task in tasks {
            task.await?;
        }
        
        Ok(())
    }
    
    /// 运行直到完成
    pub fn block_on<F>(&self, future: F) -> F::Output
    where
        F: Future,
    {
        self.runtime.block_on(future)
    }
}

/// 批量任务处理器
pub struct BatchProcessor<T> {
    batch_size: usize,
    timeout: Duration,
    buffer: Vec<T>,
    last_flush: Instant,
}

impl<T> BatchProcessor<T> {
    pub fn new(batch_size: usize, timeout: Duration) -> Self {
        Self {
            batch_size,
            timeout,
            buffer: Vec::with_capacity(batch_size),
            last_flush: Instant::now(),
        }
    }
    
    /// 添加项目到批次
    pub fn add(&mut self, item: T) -> Option<Vec<T>> {
        self.buffer.push(item);
        
        if self.buffer.len() >= self.batch_size {
            Some(std::mem::take(&mut self.buffer))
        } else {
            None
        }
    }
    
    /// 检查是否需要刷新
    pub fn should_flush(&self) -> bool {
        !self.buffer.is_empty() && self.last_flush.elapsed() >= self.timeout
    }
    
    /// 强制刷新
    pub fn flush(&mut self) -> Vec<T> {
        self.last_flush = Instant::now();
        std::mem::take(&mut self.buffer)
    }
}

/// 并行映射器
pub struct ParallelMapper {
    worker_count: usize,
}

impl ParallelMapper {
    pub fn new(worker_count: usize) -> Self {
        Self { worker_count }
    }
    
    /// 并行映射
    pub async fn map<T, R, F, Fut>(&self, items: Vec<T>, mapper: F) -> Result<Vec<R>, JoinError>
    where
        T: Send + 'static,
        R: Send + 'static,
        F: Fn(T) -> Fut + Send + Sync + 'static,
        Fut: Future<Output = R> + Send + 'static,
    {
        let mapper = Arc::new(mapper);
        let semaphore = Arc::new(Semaphore::new(self.worker_count));
        
        let tasks: Vec<_> = items
            .into_iter()
            .map(|item| {
                let mapper = mapper.clone();
                let semaphore = semaphore.clone();
                
                tokio::spawn(async move {
                    let _permit = semaphore.acquire().await.unwrap();
                    mapper(item).await
                })
            })
            .collect();
        
        let mut results = Vec::with_capacity(tasks.len());
        for task in tasks {
            results.push(task.await?);
        }
        
        Ok(results)
    }
    
    /// 并行过滤映射
    pub async fn filter_map<T, R, F, Fut>(
        &self, 
        items: Vec<T>, 
        mapper: F
    ) -> Result<Vec<R>, JoinError>
    where
        T: Send + 'static,
        R: Send + 'static,
        F: Fn(T) -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Option<R>> + Send + 'static,
    {
        let results = self.map(items, mapper).await?;
        Ok(results.into_iter().flatten().collect())
    }
}
```

## 实用工具

### rspack_util - 通用工具

```rust
/// 资源条件匹配
pub mod asset_condition {
    use super::*;
    
    /// 资源条件
    #[derive(Debug, Clone)]
    pub enum AssetCondition {
        /// 字符串匹配
        String(String),
        /// 正则表达式匹配
        Regex(regex::Regex),
        /// 函数匹配
        Function(Arc<dyn Fn(&str) -> bool + Send + Sync>),
        /// 数组匹配（任一）
        Array(Vec<AssetCondition>),
        /// 逻辑与
        And(Vec<AssetCondition>),
        /// 逻辑或
        Or(Vec<AssetCondition>),
        /// 逻辑非
        Not(Box<AssetCondition>),
    }
    
    impl AssetCondition {
        /// 测试路径是否匹配条件
        pub fn test(&self, path: &str) -> bool {
            match self {
                AssetCondition::String(s) => path.contains(s),
                AssetCondition::Regex(regex) => regex.is_match(path),
                AssetCondition::Function(func) => func(path),
                AssetCondition::Array(conditions) => {
                    conditions.iter().any(|cond| cond.test(path))
                }
                AssetCondition::And(conditions) => {
                    conditions.iter().all(|cond| cond.test(path))
                }
                AssetCondition::Or(conditions) => {
                    conditions.iter().any(|cond| cond.test(path))
                }
                AssetCondition::Not(condition) => !condition.test(path),
            }
        }
    }
}

/// 比较器
pub mod comparators {
    /// 块大小比较器
    pub fn compare_chunk_by_size(a: &Chunk, b: &Chunk) -> std::cmp::Ordering {
        b.size().cmp(&a.size()) // 降序
    }
    
    /// 模块名称比较器
    pub fn compare_module_by_name(a: &Module, b: &Module) -> std::cmp::Ordering {
        a.identifier().cmp(&b.identifier())
    }
    
    /// 文件修改时间比较器
    pub fn compare_file_by_mtime(a: &FileMetadata, b: &FileMetadata) -> std::cmp::Ordering {
        b.modified.cmp(&a.modified) // 最新的在前
    }
}

/// 原子操作工具
pub mod atom {
    use std::sync::atomic::{AtomicUsize, Ordering};
    
    /// 原子计数器
    pub struct AtomicCounter {
        value: AtomicUsize,
    }
    
    impl AtomicCounter {
        pub fn new(initial: usize) -> Self {
            Self {
                value: AtomicUsize::new(initial),
            }
        }
        
        pub fn increment(&self) -> usize {
            self.value.fetch_add(1, Ordering::SeqCst)
        }
        
        pub fn decrement(&self) -> usize {
            self.value.fetch_sub(1, Ordering::SeqCst)
        }
        
        pub fn get(&self) -> usize {
            self.value.load(Ordering::SeqCst)
        }
        
        pub fn set(&self, value: usize) {
            self.value.store(value, Ordering::SeqCst);
        }
    }
}

/// 大小格式化
pub mod size {
    /// 格式化字节大小
    pub fn format_bytes(bytes: u64) -> String {
        const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
        
        if bytes == 0 {
            return "0 B".to_string();
        }
        
        let mut size = bytes as f64;
        let mut unit_index = 0;
        
        while size >= 1024.0 && unit_index < UNITS.len() - 1 {
            size /= 1024.0;
            unit_index += 1;
        }
        
        if unit_index == 0 {
            format!("{} {}", bytes, UNITS[unit_index])
        } else {
            format!("{:.1} {}", size, UNITS[unit_index])
        }
    }
    
    /// 解析大小字符串
    pub fn parse_size(size_str: &str) -> Result<u64, ParseSizeError> {
        let size_str = size_str.trim();
        if size_str.is_empty() {
            return Err(ParseSizeError::Empty);
        }
        
        let (number_part, unit_part) = if let Some(pos) = size_str.find(char::is_alphabetic) {
            (&size_str[..pos], &size_str[pos..])
        } else {
            (size_str, "")
        };
        
        let number: f64 = number_part.parse()
            .map_err(|_| ParseSizeError::InvalidNumber)?;
        
        let multiplier = match unit_part.to_uppercase().as_str() {
            "" | "B" => 1,
            "KB" => 1024,
            "MB" => 1024 * 1024,
            "GB" => 1024 * 1024 * 1024,
            "TB" => 1024_u64.pow(4),
            _ => return Err(ParseSizeError::InvalidUnit),
        };
        
        Ok((number * multiplier as f64) as u64)
    }
    
    #[derive(Debug, thiserror::Error)]
    pub enum ParseSizeError {
        #[error("空的大小字符串")]
        Empty,
        #[error("无效的数字")]
        InvalidNumber,
        #[error("无效的单位")]
        InvalidUnit,
    }
}
```

这些工具和辅助模块为 Rspack 提供了坚实的基础设施，包括文件系统抽象、哈希计算、路径处理、错误处理、性能追踪等核心功能。它们的设计遵循了 Rust 的最佳实践，提供了高性能、线程安全和易用的 API。