# Rspack 绑定接口模块 API 文档

## rspack_binding_api - JavaScript 绑定层

`rspack_binding_api` 是 Rspack 的核心绑定层，负责将 Rust 实现的功能暴露给 JavaScript/TypeScript 环境。

### 核心绑定类型

#### JsCompiler - 主编译器接口

```rust
/// JavaScript 编译器绑定
#[napi]
pub struct JsCompiler {
    /// 编译器状态
    state: CompilerState,
    /// JavaScript hooks 适配器
    js_hooks_adapter: Arc<JsHooksAdapterPlugin>,
    /// 虚拟文件存储
    virtual_file_store: Arc<VirtualFileStore>,
    /// 入口依赖映射
    entry_deps: HashMap<String, DependencyId>,
}

#[napi]
impl JsCompiler {
    /// 创建新的编译器实例
    #[napi(constructor)]
    pub fn new(
        raw_options: RawOptions,
        register_js_hooks: ThreadsafeFunction<CompilerHooks, ()>,
        register_js_compilation_hooks: ThreadsafeFunction<CompilationHooks, ()>,
        register_js_loader_hooks: ThreadsafeJsValueRef<JsObject>,
        plugins: Vec<BoxPlugin>,
    ) -> Result<Self>;
    
    /// 执行构建
    #[napi]
    pub fn build(&mut self) -> Result<(), ErrorCode>;
    
    /// 增量重建
    #[napi]
    pub fn rebuild(
        &mut self, 
        changed_files: Vec<String>,
        removed_files: Vec<String>
    ) -> Result<(), ErrorCode>;
    
    /// 获取编译统计信息
    #[napi]
    pub fn get_stats(&self) -> Result<JsStats>;
    
    /// 获取资源信息
    #[napi]
    pub fn get_assets(&self) -> Result<Vec<JsAsset>>;
    
    /// 获取 chunk 信息
    #[napi]
    pub fn get_chunks(&self) -> Result<Vec<JsChunk>>;
    
    /// 获取模块信息
    #[napi]
    pub fn get_modules(&self) -> Result<Vec<JsModule>>;
    
    /// 获取入口信息
    #[napi]
    pub fn get_entries(&self) -> Result<HashMap<String, JsEntry>>;
    
    /// 设置虚拟文件内容
    #[napi]
    pub fn set_virtual_file(&mut self, path: String, content: String);
    
    /// 获取虚拟文件内容
    #[napi]
    pub fn get_virtual_file(&self, path: String) -> Option<String>;
    
    /// 清理资源
    #[napi]
    pub fn cleanup(&mut self);
}
```

#### JsCompilation - 编译过程绑定

```rust
/// JavaScript 编译过程绑定
#[napi(object)]
pub struct JsCompilation {
    /// 编译 ID
    pub id: u32,
    /// 编译哈希
    pub hash: Option<String>,
    /// 资源列表
    pub assets: HashMap<String, JsAsset>,
    /// Chunk 列表
    pub chunks: Vec<JsChunk>,
    /// 模块列表  
    pub modules: Vec<JsModule>,
    /// 入口点列表
    pub entries: HashMap<String, JsEntry>,
    /// 诊断信息
    pub diagnostics: Vec<JsDiagnostic>,
}

impl JsCompilation {
    /// 获取模块图
    #[napi]
    pub fn get_module_graph(&self) -> JsModuleGraph;
    
    /// 获取 chunk 图
    #[napi]
    pub fn get_chunk_graph(&self) -> JsChunkGraph;
    
    /// 添加资源
    #[napi]
    pub fn emit_asset(&mut self, name: String, asset: JsAsset);
    
    /// 删除资源
    #[napi]
    pub fn delete_asset(&mut self, name: String);
    
    /// 获取资源源码
    #[napi]
    pub fn get_asset_source(&self, name: String) -> Option<String>;
}
```

### 模块系统绑定

#### Module - 通用模块接口

```rust
/// JavaScript 模块绑定基础类型
#[napi(object)]
pub struct Module {
    /// 模块类型
    pub module_type: String,
    /// 模块标识符
    pub identifier: String,
    /// 可读标识符
    pub readable_identifier: String,
    /// 模块大小
    pub size: u32,
    /// 构建信息
    pub build_info: Option<JsBuildInfo>,
    /// 构建元信息
    pub build_meta: Option<JsBuildMeta>,
    /// 模块上下文
    pub context: Option<String>,
    /// 模块层级
    pub layer: Option<String>,
}

impl Module {
    /// 获取模块源码
    #[napi]
    pub fn get_source(&self) -> Option<String>;
    
    /// 获取原始源码
    #[napi]
    pub fn get_original_source(&self) -> Option<String>;
    
    /// 获取模块依赖
    #[napi]
    pub fn get_dependencies(&self) -> Vec<JsDependency>;
    
    /// 获取导出信息
    #[napi]
    pub fn get_exports(&self) -> Vec<JsExportInfo>;
    
    /// 是否有副作用
    #[napi]
    pub fn has_side_effects(&self) -> bool;
}
```

#### 专门的模块类型

```rust
/// 普通模块
#[napi(object)]
pub struct NormalModule {
    #[napi(flatten)]
    pub base: Module,
    /// 请求路径
    pub request: String,
    /// 用户请求
    pub user_request: String,
    /// 原始请求
    pub raw_request: String,
    /// 资源路径
    pub resource: String,
    /// 匹配资源
    pub match_resource: Option<String>,
    /// 加载器列表
    pub loaders: Vec<JsLoader>,
}

/// 上下文模块
#[napi(object)]
pub struct ContextModule {
    #[napi(flatten)]
    pub base: Module,
    /// 上下文路径
    pub context: String,
    /// 请求模式
    pub request: String,
    /// 包含子目录
    pub recursive: bool,
    /// 正则表达式
    pub reg_exp: Option<String>,
}

/// 外部模块
#[napi(object)]  
pub struct ExternalModule {
    #[napi(flatten)]
    pub base: Module,
    /// 外部请求
    pub request: String,
    /// 外部类型
    pub external_type: String,
    /// 用户请求
    pub user_request: String,
}

/// 连接模块
#[napi(object)]
pub struct ConcatenatedModule {
    #[napi(flatten)]
    pub base: Module,
    /// 根模块
    pub root_module: String,
    /// 连接的模块列表
    pub modules: Vec<String>,
}
```

### 文件系统绑定

#### ThreadsafeNodeFS - 线程安全的 Node.js 文件系统

```rust
/// 线程安全的 Node.js 文件系统绑定
#[napi]
pub struct ThreadsafeNodeFS {
    /// Node.js 回调
    callbacks: ThreadsafeJsValueRef<JsObject>,
}

#[napi]
impl ThreadsafeNodeFS {
    /// 创建新实例
    #[napi(constructor)]
    pub fn new(callbacks: JsObject) -> Result<Self>;
    
    /// 异步读取文件
    #[napi]
    pub async fn read_file(&self, path: String) -> Result<Vec<u8>>;
    
    /// 异步写入文件
    #[napi]  
    pub async fn write_file(&self, path: String, data: Vec<u8>) -> Result<()>;
    
    /// 获取文件状态
    #[napi]
    pub async fn stat(&self, path: String) -> Result<JsFileMetadata>;
    
    /// 创建目录
    #[napi]
    pub async fn mkdir(&self, path: String) -> Result<()>;
    
    /// 读取目录
    #[napi]
    pub async fn readdir(&self, path: String) -> Result<Vec<String>>;
    
    /// 删除文件
    #[napi]
    pub async fn unlink(&self, path: String) -> Result<()>;
    
    /// 删除目录
    #[napi]
    pub async fn rmdir(&self, path: String) -> Result<()>;
}
```

#### HybridFileSystem - 混合文件系统

```rust
/// 混合文件系统 - 结合内存和磁盘文件系统
#[napi]
pub struct HybridFileSystem {
    memory_fs: Arc<MemoryFileSystem>,
    native_fs: Arc<NativeFileSystem>,
}

#[napi]
impl HybridFileSystem {
    /// 创建新的混合文件系统
    #[napi(constructor)]
    pub fn new() -> Self;
    
    /// 设置内存文件
    #[napi]
    pub fn set_memory_file(&mut self, path: String, content: Vec<u8>);
    
    /// 获取内存文件
    #[napi]
    pub fn get_memory_file(&self, path: String) -> Option<Vec<u8>>;
    
    /// 清除内存文件
    #[napi]
    pub fn clear_memory(&mut self);
    
    /// 列出内存文件
    #[napi]
    pub fn list_memory_files(&self) -> Vec<String>;
}
```

### 解析器绑定

#### JsResolver - 模块解析器

```rust
/// JavaScript 解析器接口
#[napi]
pub struct JsResolver {
    resolver: Arc<Resolver>,
}

#[napi]
impl JsResolver {
    /// 创建解析器
    #[napi(constructor)]
    pub fn new(options: JsResolveOptions) -> Result<Self>;
    
    /// 解析模块请求
    #[napi]
    pub async fn resolve(
        &self,
        context: String,
        request: String,
    ) -> Result<JsResolveResult>;
    
    /// 同步解析
    #[napi]
    pub fn resolve_sync(
        &self,
        context: String,
        request: String,
    ) -> Result<JsResolveResult>;
}

/// 解析结果
#[napi(object)]
pub struct JsResolveResult {
    /// 解析路径
    pub path: String,
    /// 查询参数
    pub query: Option<String>,
    /// 片段
    pub fragment: Option<String>,
    /// 描述文件路径
    pub description_file_path: Option<String>,
    /// 描述文件数据
    pub description_file_data: Option<String>,
}
```

#### JsResolverFactory - 解析器工厂

```rust
/// 解析器工厂
#[napi]
pub struct JsResolverFactory {
    factory: Arc<ResolverFactory>,
}

#[napi]
impl JsResolverFactory {
    /// 创建解析器工厂
    #[napi(constructor)]
    pub fn new(options: JsResolverFactoryOptions) -> Result<Self>;
    
    /// 获取普通模块解析器
    #[napi]
    pub fn get_normal_resolver(&self) -> JsResolver;
    
    /// 获取上下文解析器
    #[napi]
    pub fn get_context_resolver(&self) -> JsResolver;
    
    /// 获取加载器解析器
    #[napi]
    pub fn get_loader_resolver(&self) -> JsResolver;
}
```

### 插件系统绑定

#### JsHooksAdapterPlugin - JavaScript 钩子适配器

```rust
/// JavaScript 钩子适配器插件
pub struct JsHooksAdapterPlugin {
    /// 编译器钩子注册函数
    register_compiler_hooks: ThreadsafeFunction<CompilerHooks, ()>,
    /// 编译钩子注册函数
    register_compilation_hooks: ThreadsafeFunction<CompilationHooks, ()>,
    /// 加载器钩子注册函数
    register_loader_hooks: ThreadsafeJsValueRef<JsObject>,
}

impl JsHooksAdapterPlugin {
    /// 创建适配器
    pub fn new(
        register_compiler_hooks: ThreadsafeFunction<CompilerHooks, ()>,
        register_compilation_hooks: ThreadsafeFunction<CompilationHooks, ()>,
        register_loader_hooks: ThreadsafeJsValueRef<JsObject>,
    ) -> Self;
    
    /// 调用 JavaScript 钩子
    pub fn call_js_hook<T: Serialize>(
        &self,
        hook_name: &str,
        args: T,
    ) -> Result<()>;
    
    /// 调用异步 JavaScript 钩子
    pub async fn call_js_hook_async<T: Serialize>(
        &self,
        hook_name: &str,
        args: T,
    ) -> Result<()>;
}
```

### 配置选项绑定

#### RawOptions - 原始配置选项

```rust
/// 原始配置选项 - 从 JavaScript 传入的配置
#[napi(object)]
pub struct RawOptions {
    /// 编译模式
    pub mode: Option<String>,
    /// 目标环境
    pub target: Option<Vec<String>>,
    /// 上下文目录
    pub context: Option<String>,
    /// 入口配置
    pub entry: RawEntryOptions,
    /// 输出配置
    pub output: RawOutputOptions,
    /// 模块配置
    pub module: RawModuleOptions,
    /// 解析配置
    pub resolve: RawResolveOptions,
    /// 优化配置
    pub optimization: RawOptimizationOptions,
    /// 实验性功能
    pub experiments: RawExperimentsOptions,
    /// 开发工具配置
    pub devtool: Option<String>,
    /// 外部依赖
    pub externals: Option<RawExternals>,
    /// 统计信息配置
    pub stats: RawStatsOptions,
    /// 缓存配置
    pub cache: RawCacheOptions,
    /// Node.js 配置
    pub node: RawNodeOptions,
}

impl RawOptions {
    /// 转换为内部配置选项
    pub fn try_into_compiler_options(
        self,
        context: &Context
    ) -> Result<CompilerOptions>;
}
```

### 错误和诊断

#### JsDiagnostic - 诊断信息

```rust
/// JavaScript 诊断信息
#[napi(object)]
pub struct JsDiagnostic {
    /// 严重程度
    pub severity: String,
    /// 错误消息
    pub message: String,
    /// 模块标识符
    pub module_identifier: Option<String>,
    /// 模块名称
    pub module_name: Option<String>,
    /// 位置信息
    pub loc: Option<JsLocation>,
    /// 文件路径
    pub file: Option<String>,
    /// 堆栈跟踪
    pub stack: Option<String>,
}

/// 位置信息
#[napi(object)]
pub struct JsLocation {
    /// 开始行号
    pub start_line: u32,
    /// 开始列号
    pub start_column: u32,
    /// 结束行号
    pub end_line: u32,
    /// 结束列号
    pub end_column: u32,
}
```

#### ErrorCode - 错误代码

```rust
/// NAPI 错误代码
#[repr(u32)]
pub enum ErrorCode {
    /// 通用错误
    GenericFailure = 1,
    /// 无效参数
    InvalidArg = 2,
    /// 对象预期
    ObjectExpected = 3,
    /// 字符串预期
    StringExpected = 4,
    /// 名称预期
    NameExpected = 5,
    /// 函数预期
    FunctionExpected = 6,
    /// 数字预期
    NumberExpected = 7,
    /// 布尔值预期
    BooleanExpected = 8,
    /// 数组预期
    ArrayExpected = 9,
    /// 取消操作
    Cancelled = 10,
}
```

### 统计信息绑定

#### JsStats - 编译统计

```rust
/// JavaScript 统计信息
#[napi(object)]
pub struct JsStats {
    /// 编译哈希
    pub hash: Option<String>,
    /// 构建时间
    pub time: u64,
    /// 构建时间戳
    pub built_at: u64,
    /// 公共路径
    pub public_path: String,
    /// 输出路径
    pub output_path: String,
    /// 资源列表
    pub assets: Vec<JsAssetInfo>,
    /// Chunk 列表
    pub chunks: Vec<JsChunkInfo>,
    /// 模块列表
    pub modules: Vec<JsModuleInfo>,
    /// 入口点列表
    pub entry_points: HashMap<String, JsEntryPointInfo>,
    /// 错误列表
    pub errors: Vec<JsDiagnostic>,
    /// 警告列表
    pub warnings: Vec<JsDiagnostic>,
}
```

### 异步处理和回调

#### ThreadsafeFunction - 线程安全函数

```rust
/// 线程安全的 JavaScript 函数调用
pub struct ThreadsafeFunction<T, R> {
    inner: napi::ThreadsafeFunction<T, R>,
}

impl<T, R> ThreadsafeFunction<T, R>
where
    T: 'static + Send,
    R: 'static + Send,
{
    /// 创建线程安全函数
    pub fn new(func: JsFunction) -> Result<Self>;
    
    /// 调用函数
    pub fn call(&self, value: T) -> Result<()>;
    
    /// 异步调用函数
    pub async fn call_async(&self, value: T) -> Result<R>;
    
    /// 阻塞调用函数
    pub fn call_blocking(&self, value: T) -> Result<R>;
}
```

### 虚拟模块系统

#### VirtualFileStore - 虚拟文件存储

```rust
/// 虚拟文件存储系统
pub struct VirtualFileStore {
    files: Arc<RwLock<HashMap<String, String>>>,
}

impl VirtualFileStore {
    /// 创建新的虚拟文件存储
    pub fn new() -> Self;
    
    /// 设置虚拟文件
    pub fn set_file(&self, path: String, content: String);
    
    /// 获取虚拟文件
    pub fn get_file(&self, path: &str) -> Option<String>;
    
    /// 删除虚拟文件
    pub fn remove_file(&self, path: &str) -> bool;
    
    /// 列出所有虚拟文件
    pub fn list_files(&self) -> Vec<String>;
    
    /// 清除所有虚拟文件
    pub fn clear(&self);
}
```

### 使用示例

#### 基础 JavaScript 集成

```javascript
const { JsCompiler } = require('@rspack/binding');

// 创建编译器
const compiler = new JsCompiler(
  // 原始配置选项
  {
    mode: 'development',
    entry: {
      main: './src/index.js'
    },
    output: {
      path: './dist',
      filename: '[name].js'
    }
  },
  // 编译器钩子注册
  (hooks) => {
    hooks.beforeRun.tap('MyPlugin', (compiler) => {
      console.log('构建开始');
    });
  },
  // 编译钩子注册
  (hooks) => {
    hooks.emit.tap('MyPlugin', (compilation) => {
      console.log('资源输出');
    });
  },
  // 加载器钩子
  {},
  // 插件列表
  []
);

// 执行构建
compiler.build();

// 获取统计信息
const stats = compiler.getStats();
console.log('构建完成:', stats);
```

#### 虚拟文件系统使用

```javascript
const { JsCompiler } = require('@rspack/binding');

const compiler = new JsCompiler(/* ... */);

// 设置虚拟文件
compiler.setVirtualFile('/virtual/config.js', `
  export default {
    apiUrl: process.env.API_URL || 'http://localhost:3000'
  };
`);

// 在入口文件中导入虚拟文件
compiler.setVirtualFile('/src/index.js', `
  import config from '/virtual/config.js';
  console.log('API URL:', config.apiUrl);
`);

compiler.build();
```

#### 自定义文件系统

```javascript
const { ThreadsafeNodeFS } = require('@rspack/binding');

// 创建自定义文件系统
const customFS = new ThreadsafeNodeFS({
  readFile: async (path) => {
    // 自定义读取逻辑
    console.log('读取文件:', path);
    return require('fs').promises.readFile(path);
  },
  writeFile: async (path, data) => {
    // 自定义写入逻辑  
    console.log('写入文件:', path);
    return require('fs').promises.writeFile(path, data);
  },
  stat: async (path) => {
    return require('fs').promises.stat(path);
  }
});

// 在编译器中使用自定义文件系统
const compiler = new JsCompiler(options, ...);
```

### 性能优化

#### 内存管理

- **弱引用**: 使用弱引用避免 JavaScript 和 Rust 之间的循环引用
- **资源清理**: 及时清理不再使用的 NAPI 对象
- **批量操作**: 减少 JavaScript 和 Rust 之间的频繁调用
- **缓存复用**: 缓存昂贵的计算结果和对象

#### 并发处理

- **异步 API**: 大部分操作都提供异步版本
- **线程安全**: 所有绑定类型都是线程安全的
- **并行编译**: 支持多个编译实例并行运行
- **事件驱动**: 基于事件的钩子系统，避免阻塞

#### 类型安全

- **TypeScript 类型**: 自动生成 TypeScript 类型定义
- **运行时检查**: 在 Rust 侧进行参数验证
- **错误传播**: 将 Rust 错误安全地传播到 JavaScript
- **内存安全**: 避免 buffer overflow 和 use-after-free 等问题

这个绑定接口模块为 JavaScript 开发者提供了完整且高性能的 Rspack API，同时保持了 Rust 的安全性和性能优势。