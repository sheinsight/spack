# Rspack 核心模块 API 文档

## rspack_core - 核心框架

`rspack_core` 是 Rspack 的核心 crate，提供了打包器的所有基础功能和架构。

### 主要公共类型

#### 核心枚举

```rust
/// 模块类型定义
pub enum ModuleType {
    Js,                    // JavaScript 模块
    JsAuto,               // 自动检测的 JavaScript 模块
    JsEsm,                // ES 模块
    JsDynamic,            // 动态 JavaScript 模块
    Css,                  // CSS 模块
    CssModule,            // CSS 模块化
    Asset,                // 资源文件
    AssetInline,          // 内联资源
    AssetResource,        // 资源引用
    AssetSource,          // 资源源码
    Wasm,                 // WebAssembly
    // 更多类型...
}

/// 源代码类型
pub enum SourceType {
    JavaScript,           // JavaScript 源码
    Css,                 // CSS 源码
    Asset,               // 资源文件
    Wasm,                // WebAssembly
    Unknown,             // 未知类型
}

/// 依赖类型
pub enum DependencyType {
    EsmImport,           // ES 模块导入
    EsmExport,           // ES 模块导出
    CjsRequire,          // CommonJS require
    CjsExports,          // CommonJS exports
    DynamicImport,       // 动态导入
    Entry,               // 入口依赖
    // 更多类型...
}
```

#### 核心数据结构

```rust
/// 构建信息
pub struct BuildInfo {
    pub cacheable: bool,                    // 是否可缓存
    pub hash: Option<u64>,                  // 内容哈希
    pub strict: bool,                       // 严格模式
    pub side_effects: bool,                 // 是否有副作用
    pub asset_filenames: Vec<String>,       // 资源文件名
    pub value_dependencies: Vec<String>,    // 值依赖
    // 更多字段...
}

/// 构建上下文
pub struct BuildContext<'a> {
    pub compiler_options: &'a CompilerOptions,
    pub module_context: &'a Context,
    pub plugin_driver: &'a PluginDriver,
    pub resolver_factory: &'a ResolverFactory,
    pub cache: &'a dyn Cache,
    // 更多字段...
}

/// Chunk 管理结构
pub type ChunkByUkey = IdentifierMap<ChunkUkey, Chunk>;
pub type ChunkGroupByUkey = IdentifierMap<ChunkGroupUkey, ChunkGroup>;
```

### 核心 Trait

#### Module Trait

```rust
/// 模块的核心 trait
pub trait Module: Debug + Send + Sync {
    /// 获取模块类型
    fn module_type(&self) -> &ModuleType;
    
    /// 获取支持的源类型
    fn source_types(&self) -> &[SourceType];
    
    /// 获取模块大小
    fn size(&self, source_type: &SourceType) -> f64;
    
    /// 异步构建方法
    async fn build(
        &mut self,
        build_context: BuildContext<'_>,
        compilation: &mut Compilation,
    ) -> Result<TWithDiagnosticArray<BuildResult>>;
    
    /// 代码生成
    fn code_generation(
        &self,
        compilation: &Compilation,
        runtime: Option<&RuntimeSpec>,
        source_type: Option<&SourceType>,
    ) -> Result<CodeGenerationResult>;
    
    /// 获取构建元信息
    fn build_meta(&self) -> Option<&BuildMeta>;
    
    /// 获取构建信息
    fn build_info(&self) -> Option<&BuildInfo>;
    
    /// 获取模块标识符
    fn identifier(&self) -> Identifier;
    
    /// 获取可读标识符
    fn readable_identifier(&self, context: &Context) -> Cow<str>;
}
```

#### Dependency Trait

```rust
/// 依赖的核心 trait
pub trait Dependency: Debug + Send + Sync + DynEq + DynHash {
    /// 获取依赖 ID
    fn id(&self) -> &DependencyId;
    
    /// 获取依赖类型
    fn dependency_type(&self) -> &DependencyType;
    
    /// 获取依赖分类
    fn category(&self) -> &DependencyCategory;
    
    /// 获取依赖位置信息
    fn loc(&self) -> Option<String>;
    
    /// 获取资源标识符
    fn resource_identifier(&self) -> Option<&str>;
    
    /// 是否可选依赖
    fn is_optional(&self) -> bool;
    
    /// 获取导出信息
    fn get_exports(&self, mg: &ModuleGraph) -> Option<ExportsSpec>;
    
    /// 获取引用导出信息
    fn get_referenced_exports(
        &self,
        module_graph: &ModuleGraph,
        runtime: Option<&RuntimeSpec>,
    ) -> Vec<ExtendedReferencedExport>;
}
```

#### Plugin Trait

```rust
/// 插件系统核心 trait
pub trait Plugin: Debug + Send + Sync {
    /// 插件名称
    fn name(&self) -> &'static str;
    
    /// 应用插件到编译器
    fn apply(
        &self,
        ctx: &mut ApplyContext<'_>
    ) -> Result<()>;
    
    /// 插件阶段
    fn stage(&self) -> i32 {
        0
    }
}

/// 应用上下文
pub struct ApplyContext<'a> {
    pub context: &'a Context,
    pub compiler_options: &'a CompilerOptions,
    pub compiler_hooks: &'a mut CompilerHooks,
    pub resolver_factory: &'a ResolverFactory,
    pub normal_module_hooks: &'a NormalModuleHooks,
    // 更多字段...
}
```

### 编译器和编译

#### Compiler

```rust
/// 编译器主结构
pub struct Compiler {
    pub options: Arc<CompilerOptions>,
    pub output_filesystem: Arc<dyn WritableFileSystem>,
    pub compilation: Option<Compilation>,
    pub plugin_driver: SharedPluginDriver,
    pub resolver_factory: Arc<ResolverFactory>,
    pub loader_runner_runner: Arc<LoaderRunnerRunner>,
    pub cache: Arc<dyn Cache>,
    pub hooks: CompilerHooks,
    // 更多字段...
}

impl Compiler {
    /// 创建新的编译器
    pub fn new(
        options: CompilerOptions,
        plugins: Vec<BoxPlugin>,
        output_filesystem: Arc<dyn WritableFileSystem>,
        input_filesystem: Arc<dyn FileSystem>,
    ) -> Result<Self>;
    
    /// 执行构建
    pub async fn build(&mut self) -> Result<()>;
    
    /// 增量构建
    pub async fn rebuild(
        &mut self,
        changed_files: impl IntoIterator<Item = String>,
        removed_files: impl IntoIterator<Item = String>,
    ) -> Result<()>;
}
```

#### Compilation

```rust
/// 编译过程主结构
pub struct Compilation {
    pub options: Arc<CompilerOptions>,
    pub entries: HashMap<String, EntryData>,
    pub global_entry: EntryData,
    pub module_graph: ModuleGraph,
    pub chunk_graph: ChunkGraph,
    pub chunk_by_ukey: ChunkByUkey,
    pub chunk_group_by_ukey: ChunkGroupByUkey, 
    pub assets: CompilationAssets,
    pub hooks: CompilationHooks,
    // 更多字段...
}

impl Compilation {
    /// 添加入口
    pub fn add_entry(
        &mut self,
        entry: BoxDependency,
        options: EntryOptions,
    ) -> Result<()>;
    
    /// 创建模块
    pub async fn build_module(&mut self, module: BoxModule) -> Result<()>;
    
    /// 处理模块依赖
    pub async fn process_dependencies(&mut self) -> Result<()>;
    
    /// 优化模块
    pub fn optimize_modules(&mut self) -> Result<()>;
    
    /// 生成代码
    pub fn code_generation(&mut self) -> Result<()>;
    
    /// 创建 chunk 资源
    pub fn create_chunk_assets(&mut self) -> Result<()>;
}
```

### 模块系统

#### NormalModule

```rust
/// 普通模块实现
pub struct NormalModule {
    layer: Option<String>,
    request: String,
    user_request: String,
    raw_request: String,
    resource_resolve_data: ResourceData,
    parser_and_generator: BoxParserAndGenerator,
    match_resource: Option<String>,
    loaders: Vec<BoxLoader>,
    // 更多字段...
}

impl NormalModule {
    /// 创建新的普通模块
    pub fn new(create_data: NormalModuleCreateData) -> Self;
    
    /// 获取源码
    pub fn source(&self) -> Option<&BoxSource>;
    
    /// 获取原始源码
    pub fn original_source(&self) -> Option<&BoxSource>;
    
    /// 应用 loader
    pub async fn run_loaders(&mut self, compilation: &Compilation) -> Result<()>;
}
```

#### ExternalModule

```rust
/// 外部模块实现
pub struct ExternalModule {
    request: String,
    external_type: ExternalType,
    user_request: String,
    // 更多字段...
}

impl ExternalModule {
    /// 创建外部模块
    pub fn new(
        request: String,
        external_type: ExternalType,
        user_request: String,
    ) -> Self;
}
```

### 缓存系统

#### Cache Trait

```rust
/// 缓存系统核心 trait
pub trait Cache: Debug + Send + Sync {
    /// 获取缓存项
    fn get<T>(&self, key: &str) -> Option<T>
    where
        T: for<'de> Deserialize<'de>;
    
    /// 设置缓存项
    fn set<T>(&self, key: &str, value: T)
    where  
        T: Serialize;
        
    /// 清除缓存
    fn clear(&self);
    
    /// 获取缓存统计
    fn stats(&self) -> CacheStats;
}

/// 内存缓存实现
pub struct MemoryCache {
    cache: Arc<RwLock<HashMap<String, Vec<u8>>>>,
}

/// 持久化缓存实现  
pub struct PersistentCache {
    cache_dir: PathBuf,
    version: String,
    // 更多字段...
}
```

### 钩子系统

#### CompilerHooks

```rust
/// 编译器钩子
pub struct CompilerHooks {
    pub environment: AsyncSeriesHook<()>,
    pub after_environment: AsyncSeriesHook<()>,
    pub initialize: AsyncSeriesHook<()>,
    pub before_run: AsyncSeriesHook<Compiler>,
    pub run: AsyncSeriesHook<Compiler>,
    pub watch_run: AsyncSeriesHook<Compiler>,
    pub before_compile: AsyncSeriesHook<CompilationParams>,
    pub compile: SyncSeriesHook<CompilationParams>,
    pub compilation: SyncSeriesHook<(&mut Compilation, CompilationParams)>,
    pub make: AsyncSeriesHook<Compilation>,
    pub after_compile: AsyncSeriesHook<Compilation>,
    pub emit: AsyncSeriesHook<Compilation>,
    pub after_emit: AsyncSeriesHook<Compilation>,
    pub done: AsyncSeriesHook<Stats>,
    pub failed: SyncSeriesHook<Error>,
    // 更多钩子...
}
```

#### CompilationHooks

```rust
/// 编译过程钩子
pub struct CompilationHooks {
    pub build_module: SyncSeriesHook<BoxModule>,
    pub succeed_module: SyncSeriesHook<BoxModule>,
    pub still_valid_module: SyncSeriesHook<BoxModule>,
    pub add_entry: SyncSeriesHook<(BoxDependency, EntryOptions)>,
    pub failed_entry: SyncSeriesHook<(BoxDependency, EntryOptions, Error)>,
    pub succeed_entry: SyncSeriesHook<(BoxDependency, EntryOptions, Option<BoxModule>)>,
    pub optimize_modules: SyncBailHook<Vec<BoxModule>, bool>,
    pub after_optimize_modules: SyncSeriesHook<Vec<BoxModule>>,
    pub optimize_chunks: SyncBailHook<Vec<ChunkUkey>, bool>,
    pub optimize_chunk_modules: AsyncSeriesBailHook<(Vec<ChunkUkey>, Vec<BoxModule>), bool>,
    pub chunk_asset: SyncSeriesHook<(ChunkUkey, String)>,
    pub process_assets: AsyncSeriesHook<CompilationAssets>,
    // 更多钩子...
}
```

### 使用示例

#### 基本使用

```rust
use rspack_core::*;

// 创建编译器选项
let options = CompilerOptions {
    mode: Some(Mode::Development),
    entry: HashMap::from([
        ("main".to_string(), EntryDescription::from("./src/index.js"))
    ]),
    output: OutputOptions {
        path: Some("/dist".into()),
        filename: Some(Filename::from("[name].js")),
        ..Default::default()
    },
    ..Default::default()
};

// 创建编译器
let mut compiler = Compiler::new(
    options,
    vec![], // 插件列表
    Arc::new(NativeFileSystem),
    Arc::new(NativeFileSystem),
)?;

// 执行构建
compiler.build().await?;
```

#### 插件开发

```rust
use rspack_core::*;

#[derive(Debug)]
struct MyPlugin;

impl Plugin for MyPlugin {
    fn name(&self) -> &'static str {
        "MyPlugin"
    }
    
    fn apply(&self, ctx: &mut ApplyContext) -> Result<()> {
        ctx.compiler_hooks
            .compilation
            .tap(compilation_hook::new(self));
        Ok(())
    }
}

fn compilation_hook() -> impl Fn(&mut Compilation, &CompilationParams) + Send + Sync {
    |compilation, _params| {
        println!("编译开始: {}", compilation.options.mode.as_ref().unwrap());
    }
}
```

## 性能特性

- **并行处理**: 使用 `rayon` 和 `tokio` 实现并行编译和异步处理
- **增量编译**: 智能依赖图分析，只重新编译变化的模块
- **缓存优化**: 多层缓存系统，包括内存缓存和持久化缓存
- **内存管理**: 使用 `Arc` 和弱引用避免内存泄漏
- **零拷贝**: 在可能的情况下避免不必要的数据复制

## 扩展性

- **插件架构**: 统一的插件接口和丰富的钩子系统
- **模块化设计**: 高内聚低耦合的模块组织
- **trait 抽象**: 通过 trait 定义核心接口，便于扩展
- **动态配置**: 支持运行时配置和动态插件注册